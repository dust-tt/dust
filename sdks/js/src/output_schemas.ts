import { z } from "zod";

import { INTERNAL_MIME_TYPES } from "./internal_mime_types";
import { NotificationSchema } from "./raw_mcp_types";
import type { CallToolResult, Notification } from "./raw_mcp_types.ts";

// File generated by the tool during its execution.

const ToolGeneratedFileSchema = z.object({
  text: z.string(),
  uri: z.string(),
  mimeType: z.literal(INTERNAL_MIME_TYPES.TOOL_OUTPUT.FILE),
  fileId: z.string(),
  title: z.string(),
  contentType: z.string(),
  snippet: z.string().nullable(),
});

export type ToolGeneratedFileType = z.infer<typeof ToolGeneratedFileSchema>;

export function isToolGeneratedFile(
  outputBlock: CallToolResult["content"][number]
): outputBlock is { type: "resource"; resource: ToolGeneratedFileType } {
  return (
    outputBlock.type === "resource" &&
    ToolGeneratedFileSchema.safeParse(outputBlock.resource).success
  );
}

// Thinking tokens generated during the tool execution.

const ThinkingOutputSchema = z.object({
  mimeType: z.literal(INTERNAL_MIME_TYPES.TOOL_OUTPUT.THINKING),
  text: z.string(),
  uri: z.literal(""),
});

export type ThinkingOutputType = z.infer<typeof ThinkingOutputSchema>;

export function isThinkingOutput(
  outputBlock: CallToolResult["content"][number]
): outputBlock is { type: "resource"; resource: ThinkingOutputType } {
  return (
    outputBlock.type === "resource" &&
    ThinkingOutputSchema.safeParse(outputBlock.resource).success
  );
}

// Final output of the reasoning when successful with the non-CoT tokens.

export const ReasoningSuccessOutputSchema = z.object({
  mimeType: z.literal(INTERNAL_MIME_TYPES.TOOL_OUTPUT.REASONING_SUCCESS),
  text: z.string(),
  uri: z.literal(""),
});

export type ReasoningSuccessOutputType = z.infer<
  typeof ReasoningSuccessOutputSchema
>;

export function isReasoningSuccessOutput(
  outputBlock: CallToolResult["content"][number]
): outputBlock is { type: "resource"; resource: ReasoningSuccessOutputType } {
  return (
    outputBlock.type === "resource" &&
    ReasoningSuccessOutputSchema.safeParse(outputBlock.resource).success
  );
}

// SQL query

const SqlQueryResourceSchema = z.object({
  mimeType: z.literal(INTERNAL_MIME_TYPES.TOOL_OUTPUT.SQL_QUERY),
  query: z.string(),
  results: z.optional(z.array(z.record(z.string(), z.unknown()))),
  error: z.optional(z.string()),
  uri: z.literal(""),
  text: z.string(),
});

export type SqlQueryResourceType = z.infer<typeof SqlQueryResourceSchema>;

export const isSqlQueryOutput = (
  outputBlock: CallToolResult["content"][number]
): outputBlock is { type: "resource"; resource: SqlQueryResourceType } => {
  return (
    outputBlock.type === "resource" &&
    SqlQueryResourceSchema.safeParse(outputBlock.resource).success
  );
};

const ExecuteTablesQueryMarkerResourceSchema = z.object({
  mimeType: z.literal(INTERNAL_MIME_TYPES.TOOL_OUTPUT.EXECUTE_TABLES_QUERY_MARKER),
  text: z.string(),
  uri: z.literal(""),
});

export type ExecuteTablesQueryMarkerResourceType = z.infer<
  typeof ExecuteTablesQueryMarkerResourceSchema
>;

export const isExecuteTablesQueryMarkerResourceType = (
  outputBlock: CallToolResult["content"][number]
): outputBlock is {
  type: "resource";
  resource: ExecuteTablesQueryMarkerResourceType;
} => {
  return (
    outputBlock.type === "resource" &&
    ExecuteTablesQueryMarkerResourceSchema.safeParse(outputBlock.resource)
      .success
  );
};

const GetDatabaseSchemaMarkerResourceSchema = z.object({
  mimeType: z.literal(INTERNAL_MIME_TYPES.TOOL_OUTPUT.GET_DATABASE_SCHEMA_MARKER),
  text: z.string(),
  uri: z.literal(""),
});

export type GetDatabaseSchemaMarkerResourceType = z.infer<
  typeof GetDatabaseSchemaMarkerResourceSchema
>;

export const isGetDatabaseSchemaMarkerResourceType = (
  outputBlock: CallToolResult["content"][number]
): outputBlock is {
  type: "resource";
  resource: GetDatabaseSchemaMarkerResourceType;
} => {
  return (
    outputBlock.type === "resource" &&
    GetDatabaseSchemaMarkerResourceSchema.safeParse(outputBlock.resource)
      .success
  );
};

const DataSourceNodeContentSchema = z.object({
  mimeType: z.literal(INTERNAL_MIME_TYPES.TOOL_OUTPUT.DATA_SOURCE_NODE_CONTENT),
  text: z.string(),
  documentId: z.string(),
  title: z.string(),
  snippet: z.string(),
  uri: z.literal(""),
});

export type DataSourceNodeContentType = z.infer<
  typeof DataSourceNodeContentSchema
>;

export const isDataSourceNodeContentType = (
  outputBlock: CallToolResult["content"][number]
): outputBlock is {
  type: "resource";
  resource: DataSourceNodeContentType;
} => {
  return (
    outputBlock.type === "resource" &&
    DataSourceNodeContentSchema.safeParse(outputBlock.resource).success
  );
};

const DataSourceNodeListSchema = z.object({
  mimeType: z.literal(INTERNAL_MIME_TYPES.TOOL_OUTPUT.DATA_SOURCE_NODE_LIST),
  text: z.string(),
  nodes: z.array(z.object({
    documentId: z.string(),
    parentId: z.string().nullable(),
    type: z.string(),
    title: z.string(),
    dustDocumentId: z.string(),
    lastUpdatedAt: z.number().nullable(),
    mime: z.string().nullable(),
  })),
  uri: z.literal(""),
});

export type DataSourceNodeListType = z.infer<
  typeof DataSourceNodeListSchema
>;

export const isDataSourceNodeListType = (
  outputBlock: CallToolResult["content"][number]
): outputBlock is {
  type: "resource";
  resource: DataSourceNodeListType;
} => {
  return (
    outputBlock.type === "resource" &&
    DataSourceNodeListSchema.safeParse(outputBlock.resource).success
  );
};

const FilesystemPathSchema = z.object({
  mimeType: z.literal(INTERNAL_MIME_TYPES.TOOL_OUTPUT.FILESYSTEM_PATH),
  text: z.string(),
  path: z.string(),
  isDirectory: z.boolean(),
  uri: z.literal(""),
});

export type FilesystemPathType = z.infer<typeof FilesystemPathSchema>;

export const isFilesystemPathType = (
  outputBlock: CallToolResult["content"][number]
): outputBlock is {
  type: "resource";
  resource: FilesystemPathType;
} => {
  return (
    outputBlock.type === "resource" &&
    FilesystemPathSchema.safeParse(outputBlock.resource).success
  );
};

const IncludeResultResourceSchema = z.object({
  mimeType: z.literal(INTERNAL_MIME_TYPES.TOOL_OUTPUT.DATA_SOURCE_INCLUDE_RESULT),
  text: z.string(),
  uri: z.literal(""),
  document: z.object({
    documentId: z.string(),
    dataSourceType: z.string(),
    dataSourceId: z.string(),
    title: z.string(),
    snippet: z.string(),
    dustDocumentId: z.string(),
    updatedAt: z.string(),
    section: z.string().nullable(),
  }),
});

export type IncludeResultResourceType = z.infer<
  typeof IncludeResultResourceSchema
>;

export const isIncludeResultResourceType = (
  outputBlock: CallToolResult["content"][number]
): outputBlock is {
  type: "resource";
  resource: IncludeResultResourceType;
} => {
  return (
    outputBlock.type === "resource" &&
    IncludeResultResourceSchema.safeParse(outputBlock.resource).success
  );
};

const SearchResultResourceSchema = z.object({
  mimeType: z.literal(INTERNAL_MIME_TYPES.TOOL_OUTPUT.DATA_SOURCE_SEARCH_RESULT),
  text: z.string(),
  uri: z.literal(""),
  documents: z.array(z.object({
    documentId: z.string(),
    dataSourceType: z.string(),
    dataSourceId: z.string(),
    title: z.string(),
    snippet: z.string(),
    dustDocumentId: z.string(),
    updatedAt: z.string(),
    tags: z.array(z.string()),
    parents: z.array(z.string()),
    sourceUrl: z.string().nullable(),
  })),
});

export type SearchResultResourceType = z.infer<
  typeof SearchResultResourceSchema
>;

export const isSearchResultResourceType = (
  outputBlock: CallToolResult["content"][number]
): outputBlock is {
  type: "resource";
  resource: SearchResultResourceType;
} => {
  return (
    outputBlock.type === "resource" &&
    SearchResultResourceSchema.safeParse(outputBlock.resource).success
  );
};

const WebsearchResultResourceSchema = z.object({
  mimeType: z.literal(INTERNAL_MIME_TYPES.TOOL_OUTPUT.WEBSEARCH_RESULT),
  text: z.string(),
  uri: z.literal(""),
  results: z.array(z.object({
    title: z.string(),
    snippet: z.string(),
    link: z.string(),
  })),
});

export type WebsearchResultResourceType = z.infer<
  typeof WebsearchResultResourceSchema
>;

export const isWebsearchResultResourceType = (
  outputBlock: CallToolResult["content"][number]
): outputBlock is {
  type: "resource";
  resource: WebsearchResultResourceType;
} => {
  return (
    outputBlock.type === "resource" &&
    WebsearchResultResourceSchema.safeParse(outputBlock.resource).success
  );
};

// Extract data outputs: query and results.

const ExtractResultResourceSchema = z.object({
  mimeType: z.literal(INTERNAL_MIME_TYPES.TOOL_OUTPUT.EXTRACT_RESULT),
  text: z.string(),
  uri: z.literal(""),
  results: z.array(z.record(z.string(), z.any())),
});

export type ExtractResultResourceType = z.infer<
  typeof ExtractResultResourceSchema
>;

export const isExtractResultResourceType = (
  outputBlock: CallToolResult["content"][number]
): outputBlock is {
  type: "resource";
  resource: ExtractResultResourceType;
} => {
  return (
    outputBlock.type === "resource" &&
    ExtractResultResourceSchema.safeParse(outputBlock.resource).success
  );
};

// Browse data outputs: query and results.

const BrowseResultResourceSchema = z.object({
  mimeType: z.literal(INTERNAL_MIME_TYPES.TOOL_OUTPUT.BROWSE_RESULT),
  text: z.string(),
  uri: z.literal(""),
  results: z.string(),
});

export type BrowseResultResourceType = z.infer<
  typeof BrowseResultResourceSchema
>;

export const isBrowseResultResourceType = (
  outputBlock: CallToolResult["content"][number]
): outputBlock is {
  type: "resource";
  resource: BrowseResultResourceType;
} => {
  return (
    outputBlock.type === "resource" &&
    BrowseResultResourceSchema.safeParse(outputBlock.resource).success
  );
};

// Run agent schemas (supports multiple queries)
export const RunAgentQueriesResourceSchema = z.object({
  mimeType: z.literal(INTERNAL_MIME_TYPES.TOOL_OUTPUT.RUN_AGENT_QUERIES),
  queries: z.array(z.string()),
  childAgentId: z.string(),
  text: z.string(),
  uri: z.literal(""),
});

export type RunAgentQueriesResourceType = z.infer<
  typeof RunAgentQueriesResourceSchema
>;

export const isRunAgentQueriesResourceType = (
  outputBlock: CallToolResult["content"][number]
): outputBlock is {
  type: "resource";
  resource: RunAgentQueriesResourceType;
} => {
  return (
    outputBlock.type === "resource" &&
    RunAgentQueriesResourceSchema.safeParse(outputBlock.resource).success
  );
};

export const RunAgentResultsResourceSchema = z.object({
  mimeType: z.literal(INTERNAL_MIME_TYPES.TOOL_OUTPUT.RUN_AGENT_RESULTS),
  results: z.array(z.object({
    conversationId: z.string(),
    query: z.string(),
    text: z.string(),
    chainOfThought: z.string().optional(),
    uri: z.string(),
    error: z.string().optional(),
    refs: z
      .record(
        z.string(),
        z.object({
          description: z.string().optional(),
          href: z.string().optional(),
          title: z.string(),
          provider: z.string(),
        })
      )
      .optional(),
  })),
  text: z.string(),
  uri: z.literal(""),
});

export type RunAgentResultsResourceType = z.infer<
  typeof RunAgentResultsResourceSchema
>;

export const isRunAgentResultsResourceType = (
  outputBlock: CallToolResult["content"][number]
): outputBlock is {
  type: "resource";
  resource: RunAgentResultsResourceType;
} => {
  return (
    outputBlock.type === "resource" &&
    RunAgentResultsResourceSchema.safeParse(outputBlock.resource).success
  );
};

// Extract data outputs: query and results.

const AgentCreationResultResourceSchema = z.object({
  mimeType: z.literal(INTERNAL_MIME_TYPES.TOOL_OUTPUT.AGENT_CREATION_RESULT),
  text: z.string(), // Required by MCP SDK
  uri: z.string(),
  mainAgent: z.object({
    id: z.string(),
    name: z.string(),
    description: z.string(),
    pictureUrl: z.string(),
    url: z.string(),
  }),
  subAgent: z.optional(z.object({
    id: z.string(),
    name: z.string(),
    description: z.string(),
    pictureUrl: z.string(),
    url: z.string(),
  })),
});

export type AgentCreationResultResourceType = z.infer<
  typeof AgentCreationResultResourceSchema
>;

export const isAgentCreationResultResourceType = (
  outputBlock: CallToolResult["content"][number]
): outputBlock is {
  type: "resource";
  resource: AgentCreationResultResourceType;
} => {
  return (
    outputBlock.type === "resource" &&
    AgentCreationResultResourceSchema.safeParse(outputBlock.resource).success
  );
};

export function isBlobResource(
  outputBlock: CallToolResult["content"][number]
): outputBlock is {
  type: "resource";
  resource: {
    uri: string;
    blob: string;
    mimeType?: string;
  };
} {
  return outputBlock.type === "resource" && "blob" in outputBlock.resource;
}

export function isTextContent(
  outputBlock: CallToolResult["content"][number]
): outputBlock is {
  type: "text";
  text: string;
} {
  return outputBlock.type === "text";
}

// We consider resources with a text field to be text content output blocks.
// TODO(mcp): rationalize the display of results for MCP to remove the need for specific checks.
export function isResourceContentWithText(
  outputBlock: CallToolResult["content"][number]
): outputBlock is {
  type: "resource";
  resource: {
    text: string;
  };
} {
  return outputBlock.type === "resource" && "text" in outputBlock.resource;
}

// Helper to extract document information from various resource types
export function extractDocumentInfo(resource: any) {
  if ('documents' in resource) {
    return resource.documents;
  }
  if ('document' in resource) {
    return [resource.document];
  }
  if ('nodes' in resource) {
    return resource.nodes;
  }
  return [];
}

// Progress notification schemas
const NotificationImageContentSchema = z.object({
  type: z.literal("image"),
  mimeType: z.string(),
});

const NotificationTextContentSchema = z.object({
  type: z.literal("text"),
  text: z.string(),
});

const NotificationInteractiveFileContentSchema = z.object({
  type: z.literal("interactive_file"),
  title: z.string(),
  updatedAt: z.string(),
  mimeType: z.string(),
  fileId: z.string(),
});

const NotificationToolApproveBubbleUpContentSchema = z.object({
  type: z.literal("tool_approval_bubble_up"),
  configurationId: z.string(),
  messageId: z.string(),
  metadata: z.object({
    mcpServerName: z.string(),
    toolName: z.string(),
    agentName: z.string(),
    pubsubMessageId: z.string().optional(),
    icon: z.string().optional(),
  }),
  conversationId: z.string(),
  actionId: z.string(),
  inputs: z.record(z.string(), z.any()),
  stake: z.enum(["high", "low", "never_ask"]).optional(),
});

const NotificationRunAgentContentSchema = z.object({
  type: z.literal("run_agent"),
  childAgentId: z.string(),
  conversationId: z.string(),
  query: z.string(),
});

const NotificationRunAgentChainOfThoughtSchema = z.object({
  type: z.literal("run_agent_chain_of_thought"),
  childAgentId: z.string(),
  conversationId: z.string(),
  chainOfThought: z.string(),
});

const NotificationRunAgentGenerationTokensSchema = z.object({
  type: z.literal("run_agent_generation_tokens"),
  childAgentId: z.string(),
  conversationId: z.string(),
  text: z.string(),
});

// Run agent progress notifications (supports multiple queries)
const NotificationRunAgentProgressSchema = z.object({
  type: z.literal("run_agent_progress"),
  childAgentId: z.string(),
  totalQueries: z.number(),
  completedQueries: z.number(),
  activeQueries: z.array(z.object({
    index: z.number(),
    query: z.string(),
    conversationId: z.string(),
    status: z.enum(["pending", "running", "completed", "failed"]),
    error: z.string().optional(),
    text: z.string().optional(),
    chainOfThought: z.string().optional(),
    uri: z.string().optional(),
  })),
});

export const ProgressNotificationOutputSchema = z
  .union([
    NotificationImageContentSchema,
    NotificationInteractiveFileContentSchema,
    NotificationRunAgentContentSchema,
    NotificationRunAgentChainOfThoughtSchema,
    NotificationRunAgentGenerationTokensSchema,
    NotificationRunAgentProgressSchema,
    NotificationTextContentSchema,
    NotificationToolApproveBubbleUpContentSchema,
  ])
  .optional();

type ProgressNotificationOutput = z.infer<
  typeof ProgressNotificationOutputSchema
>;

export type MCPProgressNotificationType = Notification & {
  params: {
    data: {
      output?: ProgressNotificationOutput;
    };
  };
};

export function isMCPProgressNotification(
  notification: unknown
): notification is MCPProgressNotificationType {
  if (NotificationSchema.safeParse(notification).success) {
    const n = notification as Notification;
    if (
      n.params &&
      "data" in n.params &&
      n.params.data &&
      typeof n.params.data === "object" &&
      "output" in n.params.data
    ) {
      const output = (n.params.data as any).output;
      if (output) {
        return ProgressNotificationOutputSchema.safeParse(output).success;
      }
    }
  }
  return false;
}

type RunAgentQueryProgressOutput = z.infer<
  typeof NotificationRunAgentContentSchema
>;

export function isRunAgentQueryProgressOutput(
  output: ProgressNotificationOutput
): output is RunAgentQueryProgressOutput {
  return (
    output !== undefined &&
    output.type === "run_agent" &&
    "childAgentId" in output
  );
}

type RunAgentChainOfThoughtProgressOutput = z.infer<
  typeof NotificationRunAgentChainOfThoughtSchema
>;

export function isRunAgentChainOfThoughtProgressOutput(
  output: ProgressNotificationOutput
): output is RunAgentChainOfThoughtProgressOutput {
  return (
    output !== undefined &&
    output.type === "run_agent_chain_of_thought" &&
    "chainOfThought" in output
  );
}

type RunAgentGenerationTokensProgressOutput = z.infer<
  typeof NotificationRunAgentGenerationTokensSchema
>;

export function isRunAgentGenerationTokensProgressOutput(
  output: ProgressNotificationOutput
): output is RunAgentGenerationTokensProgressOutput {
  return (
    output !== undefined &&
    output.type === "run_agent_generation_tokens" &&
    "text" in output &&
    !("chainOfThought" in output)
  );
}

type RunAgentProgressOutput = z.infer<
  typeof NotificationRunAgentProgressSchema
>;

export function isRunAgentProgressOutput(
  output: ProgressNotificationOutput
): output is RunAgentProgressOutput {
  return (
    output !== undefined &&
    output.type === "run_agent_progress" &&
    "totalQueries" in output
  );
}
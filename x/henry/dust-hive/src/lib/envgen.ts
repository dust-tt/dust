import { getTemporalNamespaces } from "./init";
import { CONFIG_ENV_PATH, getEnvFilePath } from "./paths";
import type { PortAllocation } from "./ports";

// Maps namespace index to env var name
const TEMPORAL_VAR_NAMES = [
  "TEMPORAL_NAMESPACE",
  "TEMPORAL_AGENT_NAMESPACE",
  "TEMPORAL_CONNECTORS_NAMESPACE",
  "TEMPORAL_RELOCATION_NAMESPACE",
] as const;

// Generate temporal namespace exports (uses shared namespace generation)
function generateTemporalExports(name: string): string {
  const namespaces = getTemporalNamespaces(name);
  return namespaces.map((ns, i) => `export ${TEMPORAL_VAR_NAMES[i]}=${ns}`).join("\n");
}

// Generate env.sh content for an environment
export function generateEnvSh(name: string, ports: PortAllocation): string {
  return `#!/bin/bash
# Generated by dust-hive for environment: ${name}
# Do not edit manually - regenerate with 'dust-hive spawn'

source ${CONFIG_ENV_PATH}

# === Ports (for services that read env vars) ===
export PORT=${ports.front}                    # Next.js
export CORE_PORT=${ports.core}               # Core API
export CONNECTORS_PORT=${ports.connectors}         # Connectors (passed via -p flag)
export OAUTH_PORT=${ports.oauth}              # OAuth

# === Temporal namespaces (per-env isolation) ===
${generateTemporalExports(name)}

# === Init script vars (for init_dev_container.sh) ===
export POSTGRES_PORT=${ports.postgres}
export POSTGRES_HOST=localhost
export QDRANT_URL=http://localhost:${ports.qdrantHttp}
export ELASTICSEARCH_INIT_URL=http://localhost:${ports.elasticsearch}

# === Inter-service URLs ===
export CORE_API=http://localhost:${ports.core}
export CONNECTORS_API=http://localhost:${ports.connectors}
export OAUTH_API=http://localhost:${ports.oauth}
export DUST_FRONT_API=http://localhost:${ports.front}
export DUST_FRONT_INTERNAL_API=http://localhost:${ports.front}
export DUST_CLIENT_FACING_URL=http://localhost:${ports.front}
export DUST_PUBLIC_URL=http://localhost:${ports.front}
export NEXT_PUBLIC_DUST_CLIENT_FACING_URL=http://localhost:${ports.front}
export CONNECTORS_PUBLIC_URL=http://localhost:${ports.connectors}

# === Database URIs ===
export FRONT_DATABASE_URI=postgres://dev:dev@localhost:${ports.postgres}/dust_front
export FRONT_DATABASE_READ_REPLICA_URI=postgres://dev:dev@localhost:${ports.postgres}/dust_front
export CORE_DATABASE_URI=postgres://dev:dev@localhost:${ports.postgres}/dust_api
export CORE_DATABASE_READ_REPLICA_URI=postgres://dev:dev@localhost:${ports.postgres}/dust_api
export CONNECTORS_DATABASE_URI=postgres://dev:dev@localhost:${ports.postgres}/dust_connectors
export CONNECTORS_DATABASE_READ_REPLICA_URI=postgres://dev:dev@localhost:${ports.postgres}/dust_connectors
export OAUTH_DATABASE_URI=postgres://dev:dev@localhost:${ports.postgres}/dust_oauth

# === Service URIs ===
export REDIS_URI=redis://localhost:${ports.redis}
export REDIS_CACHE_URI=redis://localhost:${ports.redis}
export QDRANT_CLUSTER_0_URL=http://127.0.0.1:${ports.qdrantHttp}
export ELASTICSEARCH_URL=http://localhost:${ports.elasticsearch}
export TEXT_EXTRACTION_URL=http://localhost:${ports.apacheTika}
`;
}

// Write env.sh file for an environment
export async function writeEnvSh(name: string, ports: PortAllocation): Promise<void> {
  const content = generateEnvSh(name, ports);
  const path = getEnvFilePath(name);
  await Bun.write(path, content);
}

# Model Context Protocol (MCP) Implementation Guide

This document provides a detailed overview of the Model Context Protocol (MCP) implementation in the MCP Dust Server.

## Table of Contents

- [Introduction to MCP](#introduction-to-mcp)
- [MCP Concepts](#mcp-concepts)
- [MCP Resources](#mcp-resources)
- [MCP Tools](#mcp-tools)
- [MCP Sessions](#mcp-sessions)
- [MCP Notifications](#mcp-notifications)
- [MCP Transport](#mcp-transport)
- [MCP Implementation Details](#mcp-implementation-details)

## Introduction to MCP

The Model Context Protocol (MCP) is a standardized protocol for interacting with AI models and services. It provides a consistent interface for accessing resources, executing tools, and receiving notifications.

The MCP Dust Server implements the MCP specification to provide access to Dust's AI capabilities through a standardized interface.

### Key Features of MCP

- **Resource-Oriented**: MCP is built around resources, which are identified by URIs
- **Tool-Based**: MCP provides tools for performing operations on resources
- **Session-Based**: MCP uses sessions to maintain state between requests
- **Notification-Based**: MCP uses notifications to communicate asynchronous events
- **Transport-Agnostic**: MCP can be implemented over various transport protocols

## MCP Concepts

### Resources

Resources are the core concept in MCP. A resource is an entity that can be accessed and manipulated through the protocol. Resources are identified by URIs and can have content and metadata.

### Tools

Tools are operations that can be performed on resources. A tool has a name, parameters, and a function that executes the operation.

### Sessions

Sessions maintain state between requests. A session is created when a client connects to the server and is maintained until the client disconnects or the session times out.

### Notifications

Notifications are asynchronous messages sent from the server to the client. They are used to communicate events such as resource changes, tool execution progress, and errors.

### Transport

Transport is the mechanism used to send and receive MCP messages. MCP can be implemented over various transport protocols, such as HTTP, WebSockets, or custom protocols.

## MCP Resources

### Resource URIs

MCP resources are identified by URIs with the following format:

```
dust://<path>
```

Where `<path>` is a path that identifies the resource. For example:

- `dust://workspaces`: List of workspaces
- `dust://workspaces/{workspaceId}`: Workspace details
- `dust://workspaces/{workspaceId}/agents/{agentId}`: Agent details

### Resource Templates

Resource templates define the structure of resources. A resource template includes:

- **URI Template**: A template for the resource URI
- **Name**: A human-readable name for the resource
- **Description**: A description of the resource
- **MIME Type**: The MIME type of the resource content
- **Load Function**: A function that loads the resource content

Example resource template:

```typescript
{
  uriTemplate: 'dust://workspaces/{workspaceId}',
  name: 'Workspace',
  description: 'A Dust workspace',
  mimeType: 'application/json',
  async load(args: { workspaceId: string }, context: any) {
    // Load workspace details
    return { text: JSON.stringify(workspace) };
  }
}
```

### Resource Content

Resource content is the data associated with a resource. It can be in various formats, such as JSON, text, or binary data.

Example resource content:

```json
{
  "id": "workspace-123",
  "name": "My Workspace",
  "description": "A workspace for my project",
  "createdAt": "2023-06-01T12:00:00Z",
  "updatedAt": "2023-06-01T12:00:00Z"
}
```

## MCP Tools

### Tool Definition

A tool is defined by:

- **Name**: A unique identifier for the tool
- **Description**: A description of what the tool does
- **Parameters**: The parameters that the tool accepts
- **Execute Function**: A function that executes the tool

Example tool definition:

```typescript
{
  name: 'dust/agent/execute',
  description: 'Execute an agent',
  parameters: z.object({
    workspaceId: z.string(),
    agentId: z.string(),
    input: z.string(),
    configId: z.string().optional(),
  }),
  async execute(args, context) {
    // Execute the agent
    return {
      content: [
        {
          type: 'text',
          text: JSON.stringify(result),
        },
      ],
    };
  }
}
```

### Tool Execution

Tool execution involves:

1. **Parameter Validation**: Validating the tool parameters
2. **Permission Check**: Checking if the user has permission to execute the tool
3. **Execution**: Executing the tool function
4. **Response Generation**: Generating a response based on the execution result

### Tool Response

A tool response includes:

- **Content**: The content generated by the tool
- **Metadata**: Additional information about the tool execution

Example tool response:

```json
{
  "content": [
    {
      "type": "text",
      "text": "{\"id\":\"run-123\",\"status\":\"pending\"}"
    }
  ]
}
```

## MCP Sessions

### Session Creation

A session is created when a client connects to the server. The server generates a session ID and returns it to the client.

### Session State

Session state includes:

- **Session ID**: A unique identifier for the session
- **User Information**: Information about the authenticated user
- **Context**: Additional context information for the session
- **Event Subscriptions**: Subscriptions to events for notifications

### Session Termination

A session is terminated when:

- The client disconnects
- The session times out
- The server terminates the session

## MCP Notifications

### Notification Types

MCP supports various types of notifications:

- **Resource Change**: Notifies when a resource changes
- **Tool Execution Progress**: Notifies about the progress of a tool execution
- **Error**: Notifies about errors
- **System**: Notifies about system events

### Notification Format

A notification includes:

- **Type**: The type of notification
- **Data**: The notification data
- **Timestamp**: When the notification was generated

Example notification:

```json
{
  "type": "tool.progress",
  "data": {
    "toolName": "dust/agent/execute",
    "progress": 0.5,
    "message": "Executing agent..."
  },
  "timestamp": "2023-06-01T12:00:00Z"
}
```

### Notification Delivery

Notifications are delivered to clients through the transport mechanism. The delivery can be:

- **Immediate**: Delivered as soon as the notification is generated
- **Batched**: Delivered in batches to reduce overhead
- **Filtered**: Delivered only if the client has subscribed to the notification type

## MCP Transport

### HTTP Transport

The MCP Dust Server implements MCP over HTTP using JSON-RPC:

- **Request**: A JSON-RPC request with method and params
- **Response**: A JSON-RPC response with result or error
- **Notifications**: Delivered through server-sent events or long polling

Example JSON-RPC request:

```json
{
  "jsonrpc": "2.0",
  "method": "mcp.resource.load",
  "params": {
    "uri": "dust://workspaces/123"
  },
  "id": 1
}
```

Example JSON-RPC response:

```json
{
  "jsonrpc": "2.0",
  "result": {
    "content": {
      "text": "{\"id\":\"workspace-123\",\"name\":\"My Workspace\"}"
    },
    "mimeType": "application/json"
  },
  "id": 1
}
```

### WebSocket Transport

The MCP Dust Server also supports WebSocket transport for real-time communication:

- **Connection**: A WebSocket connection is established
- **Messages**: JSON-RPC messages are sent over the WebSocket
- **Notifications**: Delivered as JSON-RPC notifications

### HTTP Stream Transport

The MCP Dust Server supports HTTP Stream transport for long-lived connections:

- **Connection**: An HTTP connection is established with the `Transfer-Encoding: chunked` header
- **Messages**: JSON-RPC messages are sent as chunks
- **Notifications**: Delivered as JSON-RPC notifications in chunks

## MCP Implementation Details

### Resource Implementation

The MCP Dust Server implements resources using the `ResourceProvider` class:

```typescript
export class ResourceProvider {
  private resources: Map<string, MCPResource>;
  
  constructor(options: ResourceProviderOptions) {
    this.resources = new Map();
    // Initialize resources
  }
  
  public registerResourceTemplate(resource: MCPResource): void {
    this.resources.set(resource.uriTemplate, resource);
  }
  
  public async getResource(uri: string, apiKey: string): Promise<ResourceContent> {
    // Find the resource template that matches the URI
    // Extract parameters from the URI
    // Check permissions
    // Load the resource content
    return content;
  }
}
```

### Tool Implementation

The MCP Dust Server implements tools using the `ToolProvider` class:

```typescript
export class ToolProvider {
  private tools: Map<string, MCPTool>;
  
  constructor(options: ToolProviderOptions) {
    this.tools = new Map();
    // Initialize tools
  }
  
  public registerTool(tool: MCPTool): void {
    this.tools.set(tool.name, tool);
  }
  
  public async executeTool(name: string, params: any, apiKey: string): Promise<ToolResponse> {
    // Find the tool
    // Validate parameters
    // Check permissions
    // Execute the tool
    return response;
  }
}
```

### Session Implementation

The MCP Dust Server implements sessions using the `SessionManager` class:

```typescript
export class SessionManager {
  private sessions: Map<string, MCPSession>;
  
  constructor(options: SessionManagerOptions) {
    this.sessions = new Map();
    // Initialize session manager
  }
  
  public createSession(apiKey: string): MCPSession {
    // Create a new session
    // Authenticate the user
    // Initialize session state
    return session;
  }
  
  public getSession(sessionId: string): MCPSession | undefined {
    return this.sessions.get(sessionId);
  }
  
  public terminateSession(sessionId: string): void {
    // Terminate the session
    this.sessions.delete(sessionId);
  }
}
```

### Notification Implementation

The MCP Dust Server implements notifications using the `NotificationManager` class:

```typescript
export class NotificationManager {
  private subscribers: Map<string, Set<MCPSession>>;
  
  constructor(options: NotificationManagerOptions) {
    this.subscribers = new Map();
    // Initialize notification manager
  }
  
  public subscribe(session: MCPSession, type: string): void {
    // Subscribe the session to the notification type
    if (!this.subscribers.has(type)) {
      this.subscribers.set(type, new Set());
    }
    this.subscribers.get(type)!.add(session);
  }
  
  public unsubscribe(session: MCPSession, type: string): void {
    // Unsubscribe the session from the notification type
    if (this.subscribers.has(type)) {
      this.subscribers.get(type)!.delete(session);
    }
  }
  
  public notify(type: string, data: any): void {
    // Notify all subscribers of the notification
    if (this.subscribers.has(type)) {
      for (const session of this.subscribers.get(type)!) {
        session.sendNotification(type, data);
      }
    }
  }
}
```

### Transport Implementation

The MCP Dust Server implements transport using Express middleware:

```typescript
export function createMCPMiddleware(options: MCPMiddlewareOptions) {
  return (req: Request, res: Response, next: NextFunction) => {
    // Parse the request
    // Create or get the session
    // Process the request
    // Send the response
  };
}
```

## MCP Protocol Reference

### Resource Methods

- **mcp.resource.load**: Load a resource
- **mcp.resource.list**: List resources
- **mcp.resource.create**: Create a resource
- **mcp.resource.update**: Update a resource
- **mcp.resource.delete**: Delete a resource

### Tool Methods

- **mcp.tool.execute**: Execute a tool
- **mcp.tool.list**: List available tools
- **mcp.tool.describe**: Get tool description

### Session Methods

- **mcp.session.create**: Create a session
- **mcp.session.terminate**: Terminate a session
- **mcp.session.ping**: Keep a session alive

### Notification Methods

- **mcp.notification.subscribe**: Subscribe to notifications
- **mcp.notification.unsubscribe**: Unsubscribe from notifications

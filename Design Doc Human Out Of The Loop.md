# Design Doc: Human Out Of The Loop

Created by: Adrien Simon
Tags: DesignDoc, Product
Created time: June 20, 2025 3:46 PM

# Context

Users want to automate agent interactions without manual intervention, but currently must manually trigger every agent conversation. This creates friction for recurring tasks, reactive workflows, and time-sensitive automations. Customers are using complex third-party solutions (Zapier, n8n, make etc.) as workarounds, creating maintenance overhead and vendor lock-in on their side. We want to natively support this.

---

# Use cases

We’re doing a use case driven approach. Our goal is to solve those use cases.

- **@DesignDaily** : Every day at 9:00 AM, get the summary of the Design world in a Slack channel.
- **@InboxSummary** : Every Monday, I want a summary of the unread e-mails I, as a user, have.
- **@CRMEnricher** : When a Gong call transcript arrives, update my CRM with new informations.
- **@PullRequestReviewer** : On a new Pull Request, I want an agent to automatically review it.

---

# Problem Space and Challenges

We either have Agents using Personal or Workspace tools.

For Agents that uses Workspace tools, no big deal of *who* runs the trigger. Everyone can watch the same conversation, given the fact that the answer won’t change modulo the temperature of the agent. No big deal of who actually runs the message, and it’ll just be the Trigger Creator.

For Agents that uses Personal tools, *who* runs the trigger is important. This means allowing people to set themselves as runners of the agent, for the agent to use their account. If the agent uses personal tools, people should not be able to watch the conversations resulting from the trigger, given that it might leak personal informations. The user might wish to let people observe some really specific runs using their account, but this is not MVP. *Note: We handle this potential future use-case by having a list of subscribers in the Trigger Model. See below, at `subscribers: ForeignKey<User>[];`*

---

# Milestones

## Milestone 1 : Basic schedules for Agent Builders

*Estimated Eng Time : 3 days. Product surface : Low*

- As an agent builder, being able to add a schedule to an agent in the Agent Builder.
- As an agent builder, being able to see the conversations generated by the schedules of my agents.
- As a developer, implementing a way for agent builders to see which conversations requires an action / are to be seen. (i.e, a high stake tool need approval).
- As a developer, implementing an easy and understandable way for users to set up a cron job.

Unlocks the **@DesignDaily** type of use-cases.

*— Here, Internal release and potentially feature-flag release to power users to battle test the feature.*

## Milestone 2 : Triggering personal tools, and subscribing to triggers

*Estimated Eng Time : 5 days. Product surface : Medium*

- As a developer, allowing agents to run personal tools with a trigger.
- As a user, being able to activate a trigger for myself (meaning, having the agent runs with my own credentials).
- As a user, being able to observe the runs of a trigger that does not use personal tools (meaning that you can subscribe to a given flow).
- As a user, being able to list the triggered agents I’m subscribed to, and manage those subscriptions. (unsubscribing).

Unlocks the **@InboxSummary** type of use-cases.

*— An external release would make sense here. Depends on the actual date when we reach that point, no big incentive to GA that during the holidays, it would be great to do a GA at the rentrée des classes with as much features as possible.*

## Milestone 3 : Webhooks as a Trigger

*Estimated Eng Time : 7 days - Product surface : High*

- As an admin, being able to subscribe to a platform’s webhooks via an OAuth flow.
- As an admin, being able to select the specific webhooks I want to subscribe to from a given platform.
- As a builder, being able to select a webhook as a trigger for an agent.
- As a builder, being able to re-use the payload of the webhook in a custom input message for the trigger run.
- As a developer, implement this functionality for 2 platforms with a service account : Modjo and Gong.

Unlocks the **@CRMEnricher** / **@PullRequestReviewer** type of use-cases.

*— Definitely an external release here especially if no GA a Milestone 2.*

## Milestone 4 : Users as Trigger Builders

*Estimated Eng Time : 7 days - Product Surface : Very High*

- As a user, I can add a trigger on an agent i’m not the builder of.
- As a agent builder, I can make the workflow I created public or not.
- As a user, I can discover easily the flows built on an agent.
- As an admin, I can easily see all the flows existing in my workspace, and monitor their use.

## Possible Extensions to be prioritized or not after those milestones :

- Extend the supported webhooks list : Do-able on the fly by (accel) engs.
- Personal webhooks : Being able to trigger an agent based on a webhook not connected to a service account, but to a personal account (e.g your gmail account receiving an email).
- Data Source observation : Being able to trigger an agent based on a data source update. (cf trackers)
- Being able to trigger high-stake tools. (means a lot of admin product impact)
- A fully-fledged inbox solution to see at a glance all required actions. Can and should completely be a separate initiative though.

---

# Implementation Bits

## Conversation State

```tsx
type ConversationParticipantModel = {
  createdAt: Date;
  updatedAt: Date;
  conversationId: ForeignKey<ConversationModel["id"]>;
  userId: int;
  
  action: ParticipantActionType; // <-- use "subscribed" Participant Type
  read: boolean; // <-- new thing
  actionRequired: boolean; // <-- new thing
}
```

A read conversation is what it is today. An unread conversation is a conversation that has not been opened since the last Agent Message finished streaming. An action_required conversation is an conversation currently running, that needs the user to either approve a tool use, or connect to a tool.

## Trigger Model

```tsx
type TriggerModel = {
  id: string;
  agentId: ForeignKey<Agent>;

  subscribers: ForeignKey<TriggerSubscribers>[]
  customPrompt?: string;
} & TriggerConfig;

type TriggerSubscribers = {
	triggerId: ForeignKey<TriggerModel>;
  subscriber: ForeignKey<User>;
}

type TriggerConfig = ScheduleConfig | WebhookConfig

type ScheduleConfig = {
	type: "schedule";
	configuration: {cron: CronExpression, timezone: TimeZone};
}

type WebhookConfig = {
	type: "webhook";
	webhookSourceViewId: ForeignKey<WebhookSource>;
	configuration: {};
}
```

## Schedules

We’ll be using temporal schedulers. They’re easy to implement, we already have the infra for it, it’s easy to run a durable agentic loop from there.

For that, when saving an agent, we’ll register a new schedule in temporal. When editing the agent, we’ll either edit the old schedule, or remove and re-create a new one if edit is not possible.

### **Web Hooks**

We’ll have a generic web hook endpoint for the triggers: `/api/v1/w/{wId}/triggers/hooks/{webhookSourceId}`.

This endpoint will :  

- Retrieve the workspace.
- Check the workspace’s rate limit for the endpoint. (avoid spamming)
    - constant rate limit, redis-based (cf helper rateLimiter)
- Retrieve the payload size and check it doesn’t overflow a given limit. (avoid memory attack)
    - 2MB
- Get an authenticator for the workspace to fetch the WHSV. (⚠️ We don’t have Public API auth there)
- Retrieve the `webhookSource`, and the `webhookSourceView` itself.
- Verify the signature to check the webhook is legit.
    - Platforms send a header with a signature with the payload.
    - Users will enter the secret in Dust. We have to match the signature with the secret. (algo specified when creating custom hook)

Once the incoming web hook is verified

- Retrieve all triggers based on that `webhookSourceViewId`.
- Launch a new conversation the same way we do for schedules !
    - payload as content fragment

### **Authentication & Permissions - Thoughts following product review.**

**Problem (who/what/when) :**

In the case of an agent that does not uses personal tool, we obviously know *when* the agent runs, *what* it runs (workspace level actions), and *who* runs it (the sender - but the result would actually be the same for anyone sending the message). In the case of personal tools, the *what* depends on the *who* (outcome of the personal actions differs depending on the *who*). Because of Personal Tools, AgentMessages results are not tied to only an Agent, but to a Human and an Agent. 

**Trigger subscription - Current state :**

Currently, an agent editor can create a trigger. He is owner of that trigger and him only can edit it. Anyone can subscribe to this trigger. The effect of the runs will actually depend on the agent itself. 
⇒ If the agent has personal tools, it will create a conversation per human subscribed.

⇒ If the agent does not, it will create a single conversation and put all human as conversation participants.

This is not clear and is misleading for users. There’s a complete behavior change depending on the agent itself, and the behavior can change any time the agent is actually modified. We need a way to have “subscribing” to a trigger a stable feature that does not change depending on something else.

**Trigger subscription - Path explorations :**
Those different paths are not always exclusive, and all valid paths.

- Share your runs :
    - The trigger owner could decide that his runs are observable by a list of humans, that them themselves determine. 
    This is actually the equivalent of mentioning a human in the conversation.
    - They can make the agent send the result in a slack channel for it to be public. 
    This is currently what is done with designDaily : it runs with @ed credentials, and is shared in a public slack channel for everyone to see. No-one needs to run it himself.
    - They could also make their trigger public (mark their trigger as open for subscription), allowing anyone to see their own runs.
- Clone triggers :
Someone create a trigger that runs with his credentials. Users can clone that trigger so that it runs with their credential also.
    - We can do it by having “Trigger templates”, built by Agent editors, not tied to a specific editor, and users can “subscribe to”/”run themselves”. The could or could not customize the template with a custom message.
    - We can also do it by having triggers still tied to an editor, and allowing users to clone the trigger. This would mean allowing editing a trigger outside of the agent builder (users not editors of the agent could clone the triggers). Users could or not customize the cloned trigger (like the custom message sent along).

Whatever paths we take, the result is that a trigger is tied to a user running it in the end.

**Decision :**

We will not build those construct yet. 
We need to decide on the best way to handle that problem. 
For now, as a BETA release, Agent editors will be able to add triggers to agents. Those won’t be shared. We will have 1 agent ↔ 1 user ↔ 1 trigger. A user creating a trigger on an agent will be the only one using it.

Questions will obviously arise from users, but this is a beta and we will examine the most common usecases to decide what “sharing” model we implement. 

---
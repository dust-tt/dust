import { applyHooks, HooksContext, addons, useState, useMemo, useChannel, useEffect } from './chunk-2WNKQWTL.mjs';
import memoize2 from 'memoizerific';
import mapValues2 from 'lodash/mapValues.js';
import pick from 'lodash/pick.js';
import { SynchronousPromise } from 'synchronous-promise';
import { MissingStoryAfterHmrError } from '@storybook/core-events/preview-errors';
import { dequal } from 'dequal';
import { once, logger, deprecate as deprecate$1 } from '@storybook/client-logger';
import isPlainObject from 'lodash/isPlainObject.js';
import dedent3, { dedent } from 'ts-dedent';
import { storyNameFromExport, toId, sanitize, isExportStory, includeConditionalArg } from '@storybook/csf';
import deprecate from 'util-deprecate';
import { global } from '@storybook/global';
import pickBy from 'lodash/pickBy.js';
import { SHARED_STATE_CHANGED, SHARED_STATE_SET } from '@storybook/core-events';

var getImportPathMap=memoize2(1)(entries=>Object.values(entries).reduce((acc,entry)=>(acc[entry.importPath]=acc[entry.importPath]||entry,acc),{})),StoryIndexStore=class{constructor({entries}={v:4,entries:{}}){this.entries=entries;}entryFromSpecifier(specifier){let entries=Object.values(this.entries);if(specifier==="*")return entries[0];if(typeof specifier=="string")return this.entries[specifier]?this.entries[specifier]:entries.find(entry=>entry.id.startsWith(specifier));let{name,title}=specifier;return entries.find(entry=>entry.name===name&&entry.title===title)}storyIdToEntry(storyId){let storyEntry=this.entries[storyId];if(!storyEntry)throw new MissingStoryAfterHmrError({storyId});return storyEntry}importPathToEntry(importPath){return getImportPathMap(this.entries)[importPath]}};var INCOMPATIBLE=Symbol("incompatible"),map=(arg,argType)=>{let type=argType.type;if(arg==null||!type||argType.mapping)return arg;switch(type.name){case"string":return String(arg);case"enum":return arg;case"number":return Number(arg);case"boolean":return String(arg)==="true";case"array":return !type.value||!Array.isArray(arg)?INCOMPATIBLE:arg.reduce((acc,item,index)=>{let mapped=map(item,{type:type.value});return mapped!==INCOMPATIBLE&&(acc[index]=mapped),acc},new Array(arg.length));case"object":return typeof arg=="string"||typeof arg=="number"?arg:!type.value||typeof arg!="object"?INCOMPATIBLE:Object.entries(arg).reduce((acc,[key,val])=>{let mapped=map(val,{type:type.value[key]});return mapped===INCOMPATIBLE?acc:Object.assign(acc,{[key]:mapped})},{});default:return INCOMPATIBLE}},mapArgsToTypes=(args,argTypes)=>Object.entries(args).reduce((acc,[key,value])=>{if(!argTypes[key])return acc;let mapped=map(value,argTypes[key]);return mapped===INCOMPATIBLE?acc:Object.assign(acc,{[key]:mapped})},{}),combineArgs=(value,update)=>Array.isArray(value)&&Array.isArray(update)?update.reduce((acc,upd,index)=>(acc[index]=combineArgs(value[index],update[index]),acc),[...value]).filter(v=>v!==void 0):!isPlainObject(value)||!isPlainObject(update)?update:Object.keys({...value,...update}).reduce((acc,key)=>{if(key in update){let combined=combineArgs(value[key],update[key]);combined!==void 0&&(acc[key]=combined);}else acc[key]=value[key];return acc},{}),validateOptions=(args,argTypes)=>Object.entries(argTypes).reduce((acc,[key,{options}])=>{function allowArg(){return key in args&&(acc[key]=args[key]),acc}if(!options)return allowArg();if(!Array.isArray(options))return once.error(dedent`
        Invalid argType: '${key}.options' should be an array.

        More info: https://storybook.js.org/docs/react/api/argtypes
      `),allowArg();if(options.some(opt=>opt&&["object","function"].includes(typeof opt)))return once.error(dedent`
        Invalid argType: '${key}.options' should only contain primitives. Use a 'mapping' for complex values.

        More info: https://storybook.js.org/docs/react/writing-stories/args#mapping-to-complex-arg-values
      `),allowArg();let isArray=Array.isArray(args[key]),invalidIndex=isArray&&args[key].findIndex(val=>!options.includes(val)),isValidArray=isArray&&invalidIndex===-1;if(args[key]===void 0||options.includes(args[key])||isValidArray)return allowArg();let field=isArray?`${key}[${invalidIndex}]`:key,supportedOptions=options.map(opt=>typeof opt=="string"?`'${opt}'`:String(opt)).join(", ");return once.warn(`Received illegal value for '${field}'. Supported options: ${supportedOptions}`),acc},{}),DEEPLY_EQUAL=Symbol("Deeply equal"),deepDiff=(value,update)=>{if(typeof value!=typeof update)return update;if(dequal(value,update))return DEEPLY_EQUAL;if(Array.isArray(value)&&Array.isArray(update)){let res=update.reduce((acc,upd,index)=>{let diff=deepDiff(value[index],upd);return diff!==DEEPLY_EQUAL&&(acc[index]=diff),acc},new Array(update.length));return update.length>=value.length?res:res.concat(new Array(value.length-update.length).fill(void 0))}return isPlainObject(value)&&isPlainObject(update)?Object.keys({...value,...update}).reduce((acc,key)=>{let diff=deepDiff(value?.[key],update?.[key]);return diff===DEEPLY_EQUAL?acc:Object.assign(acc,{[key]:diff})},{}):update},UNTARGETED="UNTARGETED";function groupArgsByTarget({args,argTypes}){let groupedArgs={};return Object.entries(args).forEach(([name,value])=>{let{target=UNTARGETED}=argTypes[name]||{};groupedArgs[target]=groupedArgs[target]||{},groupedArgs[target][name]=value;}),groupedArgs}function noTargetArgs(context){return groupArgsByTarget(context)[UNTARGETED]}function deleteUndefined(obj){return Object.keys(obj).forEach(key=>obj[key]===void 0&&delete obj[key]),obj}var ArgsStore=class{constructor(){this.initialArgsByStoryId={};this.argsByStoryId={};}get(storyId){if(!(storyId in this.argsByStoryId))throw new Error(`No args known for ${storyId} -- has it been rendered yet?`);return this.argsByStoryId[storyId]}setInitial(story){if(!this.initialArgsByStoryId[story.id])this.initialArgsByStoryId[story.id]=story.initialArgs,this.argsByStoryId[story.id]=story.initialArgs;else if(this.initialArgsByStoryId[story.id]!==story.initialArgs){let delta=deepDiff(this.initialArgsByStoryId[story.id],this.argsByStoryId[story.id]);this.initialArgsByStoryId[story.id]=story.initialArgs,this.argsByStoryId[story.id]=story.initialArgs,delta!==DEEPLY_EQUAL&&this.updateFromDelta(story,delta);}}updateFromDelta(story,delta){let validatedDelta=validateOptions(delta,story.argTypes);this.argsByStoryId[story.id]=combineArgs(this.argsByStoryId[story.id],validatedDelta);}updateFromPersisted(story,persisted){let mappedPersisted=mapArgsToTypes(persisted,story.argTypes);return this.updateFromDelta(story,mappedPersisted)}update(storyId,argsUpdate){if(!(storyId in this.argsByStoryId))throw new Error(`No args known for ${storyId} -- has it been rendered yet?`);this.argsByStoryId[storyId]=deleteUndefined({...this.argsByStoryId[storyId],...argsUpdate});}};var getValuesFromArgTypes=(argTypes={})=>Object.entries(argTypes).reduce((acc,[arg,{defaultValue}])=>(typeof defaultValue<"u"&&(acc[arg]=defaultValue),acc),{});var GlobalsStore=class{constructor({globals={},globalTypes={}}){this.set({globals,globalTypes});}set({globals={},globalTypes={}}){let delta=this.initialGlobals&&deepDiff(this.initialGlobals,this.globals);this.allowedGlobalNames=new Set([...Object.keys(globals),...Object.keys(globalTypes)]);let defaultGlobals=getValuesFromArgTypes(globalTypes);this.initialGlobals={...defaultGlobals,...globals},this.globals=this.initialGlobals,delta&&delta!==DEEPLY_EQUAL&&this.updateFromPersisted(delta);}filterAllowedGlobals(globals){return Object.entries(globals).reduce((acc,[key,value])=>(this.allowedGlobalNames.has(key)?acc[key]=value:logger.warn(`Attempted to set a global (${key}) that is not defined in initial globals or globalTypes`),acc),{})}updateFromPersisted(persisted){let allowedUrlGlobals=this.filterAllowedGlobals(persisted);this.globals={...this.globals,...allowedUrlGlobals};}get(){return this.globals}update(newGlobals){this.globals={...this.globals,...this.filterAllowedGlobals(newGlobals)};}};var normalizeType=type=>typeof type=="string"?{name:type}:type,normalizeControl=control=>typeof control=="string"?{type:control}:control,normalizeInputType=(inputType,key)=>{let{type,control,...rest}=inputType,normalized={name:key,...rest};return type&&(normalized.type=normalizeType(type)),control?normalized.control=normalizeControl(control):control===!1&&(normalized.control={disable:!0}),normalized},normalizeInputTypes=inputTypes=>mapValues2(inputTypes,normalizeInputType);var normalizeArrays=array=>Array.isArray(array)?array:array?[array]:[];var deprecatedStoryAnnotation=dedent`
CSF .story annotations deprecated; annotate story functions directly:
- StoryFn.story.name => StoryFn.storyName
- StoryFn.story.(parameters|decorators) => StoryFn.(parameters|decorators)
See https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#hoisted-csf-annotations for details and codemod.
`,deprecatedStoryAnnotationWarning=deprecate(()=>{},deprecatedStoryAnnotation);function normalizeStory(key,storyAnnotations,meta){let storyObject=storyAnnotations,userStoryFn=typeof storyAnnotations=="function"?storyAnnotations:null,{story}=storyObject;story&&(logger.debug("deprecated story",story),deprecatedStoryAnnotationWarning());let exportName=storyNameFromExport(key),name=typeof storyObject!="function"&&storyObject.name||storyObject.storyName||story?.name||exportName,decorators=[...normalizeArrays(storyObject.decorators),...normalizeArrays(story?.decorators)],parameters={...story?.parameters,...storyObject.parameters},args={...story?.args,...storyObject.args},argTypes={...story?.argTypes,...storyObject.argTypes},loaders=[...normalizeArrays(storyObject.loaders),...normalizeArrays(story?.loaders)],{render,play,tags=[]}=storyObject,id=parameters.__id||toId(meta.id,exportName);return {moduleExport:storyAnnotations,id,name,tags,decorators,parameters,args,argTypes:normalizeInputTypes(argTypes),loaders,...render&&{render},...userStoryFn&&{userStoryFn},...play&&{play}}}function normalizeComponentAnnotations(defaultExport,title=defaultExport.title,importPath){let{id,argTypes}=defaultExport;return {id:sanitize(id||title),...defaultExport,title,...argTypes&&{argTypes:normalizeInputTypes(argTypes)},parameters:{fileName:importPath,...defaultExport.parameters}}}var checkGlobals=parameters=>{let{globals,globalTypes}=parameters;(globals||globalTypes)&&logger.error("Global args/argTypes can only be set globally",JSON.stringify({globals,globalTypes}));},checkStorySort=parameters=>{let{options}=parameters;options?.storySort&&logger.error("The storySort option parameter can only be set globally");},checkDisallowedParameters=parameters=>{parameters&&(checkGlobals(parameters),checkStorySort(parameters));},checkSubcomponents=meta=>{meta.subcomponents&&deprecate$1(dedent3`The \`subcomponents\` annotation is deprecated. 
    
      Please refer to the migration guide: https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#argstable-block'
    `);};function processCSFFile(moduleExports,importPath,title){let{default:defaultExport,__namedExportsOrder,...namedExports}=moduleExports,meta=normalizeComponentAnnotations(defaultExport,title,importPath);checkDisallowedParameters(meta.parameters),checkSubcomponents(meta);let csfFile={meta,stories:{},moduleExports};return Object.keys(namedExports).forEach(key=>{if(isExportStory(key,meta)){let storyMeta=normalizeStory(key,namedExports[key],meta);checkDisallowedParameters(storyMeta.parameters),csfFile.stories[storyMeta.id]=storyMeta;}}),csfFile}var combineParameters=(...parameterSets)=>{let mergeKeys={},definedParametersSets=parameterSets.filter(Boolean),combined=definedParametersSets.reduce((acc,parameters)=>(Object.entries(parameters).forEach(([key,value])=>{let existing=acc[key];Array.isArray(value)||typeof existing>"u"?acc[key]=value:isPlainObject(value)&&isPlainObject(existing)?mergeKeys[key]=!0:typeof value<"u"&&(acc[key]=value);}),acc),{});return Object.keys(mergeKeys).forEach(key=>{let mergeValues=definedParametersSets.filter(Boolean).map(p=>p[key]).filter(value=>typeof value<"u");mergeValues.every(value=>isPlainObject(value))?combined[key]=combineParameters(...mergeValues):combined[key]=mergeValues[mergeValues.length-1];}),combined};function decorateStory(storyFn,decorator,bindWithContext){let boundStoryFunction=bindWithContext(storyFn);return context=>decorator(boundStoryFunction,context)}function sanitizeStoryContextUpdate({componentId,title,kind,id,name,story,parameters,initialArgs,argTypes,...update}={}){return update}function defaultDecorateStory(storyFn,decorators){let contextStore={},bindWithContext=decoratedStoryFn=>update=>{if(!contextStore.value)throw new Error("Decorated function called without init");return contextStore.value={...contextStore.value,...sanitizeStoryContextUpdate(update)},decoratedStoryFn(contextStore.value)},decoratedWithContextStore=decorators.reduce((story,decorator)=>decorateStory(story,decorator,bindWithContext),storyFn);return context=>(contextStore.value=context,decoratedWithContextStore(context))}function prepareStory(storyAnnotations,componentAnnotations,projectAnnotations){let{moduleExport,id,name}=storyAnnotations||{},partialAnnotations=preparePartialAnnotations(storyAnnotations,componentAnnotations,projectAnnotations),applyLoaders=async context=>{let updatedContext={...context,loaded:{}};for(let loaders of [..."__STORYBOOK_TEST_LOADERS__"in global&&Array.isArray(global.__STORYBOOK_TEST_LOADERS__)?[global.__STORYBOOK_TEST_LOADERS__]:[],normalizeArrays(projectAnnotations.loaders),normalizeArrays(componentAnnotations.loaders),normalizeArrays(storyAnnotations.loaders)]){let loadResults=await Promise.all(loaders.map(loader=>loader(updatedContext))),loaded=Object.assign({},...loadResults);updatedContext={...updatedContext,loaded:{...updatedContext.loaded,...loaded}};}return updatedContext},undecoratedStoryFn=context=>{let{passArgsFirst:renderTimePassArgsFirst=!0}=context.parameters;return renderTimePassArgsFirst?render(context.args,context):render(context)},{applyDecorators=defaultDecorateStory,runStep}=projectAnnotations,decorators=[...normalizeArrays(storyAnnotations?.decorators),...normalizeArrays(componentAnnotations?.decorators),...normalizeArrays(projectAnnotations?.decorators)],render=storyAnnotations?.userStoryFn||storyAnnotations?.render||componentAnnotations.render||projectAnnotations.render;if(!render)throw new Error(`No render function available for storyId '${id}'`);let decoratedStoryFn=applyHooks(applyDecorators)(undecoratedStoryFn,decorators),unboundStoryFn=context=>decoratedStoryFn(context),play=storyAnnotations?.play||componentAnnotations.play;return {...partialAnnotations,moduleExport,id,name,story:name,originalStoryFn:render,undecoratedStoryFn,unboundStoryFn,applyLoaders,playFunction:play&&(async storyContext=>{let playFunctionContext={...storyContext,step:(label,play2)=>runStep(label,play2,playFunctionContext)};return play(playFunctionContext)})}}function prepareMeta(componentAnnotations,projectAnnotations,moduleExport){return {...preparePartialAnnotations(void 0,componentAnnotations,projectAnnotations),moduleExport}}function preparePartialAnnotations(storyAnnotations,componentAnnotations,projectAnnotations){let tags=[...storyAnnotations?.tags||componentAnnotations.tags||[],"story"],parameters=combineParameters(projectAnnotations.parameters,componentAnnotations.parameters,storyAnnotations?.parameters),{argTypesEnhancers=[],argsEnhancers=[]}=projectAnnotations,passedArgTypes=combineParameters(projectAnnotations.argTypes,componentAnnotations.argTypes,storyAnnotations?.argTypes);if(storyAnnotations){let render=storyAnnotations?.userStoryFn||storyAnnotations?.render||componentAnnotations.render||projectAnnotations.render,{passArgsFirst=!0}=parameters;parameters.__isArgsStory=passArgsFirst&&render&&render.length>0;}let passedArgs={...projectAnnotations.args,...componentAnnotations.args,...storyAnnotations?.args},contextForEnhancers={componentId:componentAnnotations.id,title:componentAnnotations.title,kind:componentAnnotations.title,id:storyAnnotations?.id||componentAnnotations.id,name:storyAnnotations?.name||"__meta",story:storyAnnotations?.name||"__meta",component:componentAnnotations.component,subcomponents:componentAnnotations.subcomponents,tags,parameters,initialArgs:passedArgs,argTypes:passedArgTypes};contextForEnhancers.argTypes=argTypesEnhancers.reduce((accumulatedArgTypes,enhancer)=>enhancer({...contextForEnhancers,argTypes:accumulatedArgTypes}),contextForEnhancers.argTypes);let initialArgsBeforeEnhancers={...passedArgs};contextForEnhancers.initialArgs=argsEnhancers.reduce((accumulatedArgs,enhancer)=>({...accumulatedArgs,...enhancer({...contextForEnhancers,initialArgs:accumulatedArgs})}),initialArgsBeforeEnhancers);let{name,story,...withoutStoryIdentifiers}=contextForEnhancers;return withoutStoryIdentifiers}function prepareContext(context){let{args:unmappedArgs}=context,targetedContext={...context,allArgs:void 0,argsByTarget:void 0};if(global.FEATURES?.argTypeTargetsV7){let argsByTarget=groupArgsByTarget(context);targetedContext={...context,allArgs:context.args,argsByTarget,args:argsByTarget[UNTARGETED]||{}};}let mappedArgs=Object.entries(targetedContext.args).reduce((acc,[key,val])=>{if(!targetedContext.argTypes[key]?.mapping)return acc[key]=val,acc;let mappingFn=originalValue=>originalValue in targetedContext.argTypes[key].mapping?targetedContext.argTypes[key].mapping[originalValue]:originalValue;return acc[key]=Array.isArray(val)?val.map(mappingFn):mappingFn(val),acc},{}),includedArgs=Object.entries(mappedArgs).reduce((acc,[key,val])=>{let argType=targetedContext.argTypes[key]||{};return includeConditionalArg(argType,mappedArgs,targetedContext.globals)&&(acc[key]=val),acc},{});return {...targetedContext,unmappedArgs,args:includedArgs}}var inferType=(value,name,visited)=>{let type=typeof value;switch(type){case"boolean":case"string":case"number":case"function":case"symbol":return {name:type};}return value?visited.has(value)?(logger.warn(dedent`
        We've detected a cycle in arg '${name}'. Args should be JSON-serializable.

        Consider using the mapping feature or fully custom args:
        - Mapping: https://storybook.js.org/docs/react/writing-stories/args#mapping-to-complex-arg-values
        - Custom args: https://storybook.js.org/docs/react/essentials/controls#fully-custom-args
      `),{name:"other",value:"cyclic object"}):(visited.add(value),Array.isArray(value)?{name:"array",value:value.length>0?inferType(value[0],name,new Set(visited)):{name:"other",value:"unknown"}}:{name:"object",value:mapValues2(value,field=>inferType(field,name,new Set(visited)))}):{name:"object",value:{}}},inferArgTypes=context=>{let{id,argTypes:userArgTypes={},initialArgs={}}=context,argTypes=mapValues2(initialArgs,(arg,key)=>({name:key,type:inferType(arg,`${id}.${key}`,new Set)})),userArgTypesNames=mapValues2(userArgTypes,(argType,key)=>({name:key}));return combineParameters(argTypes,userArgTypesNames,userArgTypes)};inferArgTypes.secondPass=!0;var matches=(name,descriptor)=>Array.isArray(descriptor)?descriptor.includes(name):name.match(descriptor),filterArgTypes=(argTypes,include,exclude)=>!include&&!exclude?argTypes:argTypes&&pickBy(argTypes,(argType,key)=>{let name=argType.name||key;return (!include||matches(name,include))&&(!exclude||!matches(name,exclude))});var inferControl=(argType,name,matchers)=>{let{type,options}=argType;if(type){if(matchers.color&&matchers.color.test(name)){let controlType=type.name;if(controlType==="string")return {control:{type:"color"}};controlType!=="enum"&&logger.warn(`Addon controls: Control of type color only supports string, received "${controlType}" instead`);}if(matchers.date&&matchers.date.test(name))return {control:{type:"date"}};switch(type.name){case"array":return {control:{type:"object"}};case"boolean":return {control:{type:"boolean"}};case"string":return {control:{type:"text"}};case"number":return {control:{type:"number"}};case"enum":{let{value}=type;return {control:{type:value?.length<=5?"radio":"select"},options:value}}case"function":case"symbol":return null;default:return {control:{type:options?"select":"object"}}}}},inferControls=context=>{let{argTypes,parameters:{__isArgsStory,controls:{include=null,exclude=null,matchers={}}={}}}=context;if(!__isArgsStory)return argTypes;let filteredArgTypes=filterArgTypes(argTypes,include,exclude),withControls=mapValues2(filteredArgTypes,(argType,name)=>argType?.type&&inferControl(argType,name,matchers));return combineParameters(withControls,filteredArgTypes)};inferControls.secondPass=!0;function normalizeProjectAnnotations({argTypes,globalTypes,argTypesEnhancers,decorators,loaders,...annotations}){return {...argTypes&&{argTypes:normalizeInputTypes(argTypes)},...globalTypes&&{globalTypes:normalizeInputTypes(globalTypes)},decorators:normalizeArrays(decorators),loaders:normalizeArrays(loaders),argTypesEnhancers:[...argTypesEnhancers||[],inferArgTypes,inferControls],...annotations}}function composeStepRunners(stepRunners){return async(label,play,playContext)=>{await stepRunners.reduceRight((innerPlay,stepRunner)=>async()=>stepRunner(label,innerPlay,playContext),async()=>play(playContext))();}}function getField(moduleExportList,field){return moduleExportList.map(xs=>xs.default?.[field]??xs[field]).filter(Boolean)}function getArrayField(moduleExportList,field,options={}){return getField(moduleExportList,field).reduce((a,b)=>options.reverseFileOrder?[...b,...a]:[...a,...b],[])}function getObjectField(moduleExportList,field){return Object.assign({},...getField(moduleExportList,field))}function getSingletonField(moduleExportList,field){return getField(moduleExportList,field).pop()}function composeConfigs(moduleExportList){let allArgTypeEnhancers=getArrayField(moduleExportList,"argTypesEnhancers"),stepRunners=getField(moduleExportList,"runStep");return {parameters:combineParameters(...getField(moduleExportList,"parameters")),decorators:getArrayField(moduleExportList,"decorators",{reverseFileOrder:!(global.FEATURES?.legacyDecoratorFileOrder??!1)}),args:getObjectField(moduleExportList,"args"),argsEnhancers:getArrayField(moduleExportList,"argsEnhancers"),argTypes:getObjectField(moduleExportList,"argTypes"),argTypesEnhancers:[...allArgTypeEnhancers.filter(e=>!e.secondPass),...allArgTypeEnhancers.filter(e=>e.secondPass)],globals:getObjectField(moduleExportList,"globals"),globalTypes:getObjectField(moduleExportList,"globalTypes"),loaders:getArrayField(moduleExportList,"loaders"),render:getSingletonField(moduleExportList,"render"),renderToCanvas:getSingletonField(moduleExportList,"renderToCanvas"),renderToDOM:getSingletonField(moduleExportList,"renderToDOM"),applyDecorators:getSingletonField(moduleExportList,"applyDecorators"),runStep:composeStepRunners(stepRunners)}}var GLOBAL_STORYBOOK_PROJECT_ANNOTATIONS=composeConfigs([]);function setProjectAnnotations(projectAnnotations){let annotations=Array.isArray(projectAnnotations)?projectAnnotations:[projectAnnotations];GLOBAL_STORYBOOK_PROJECT_ANNOTATIONS=composeConfigs(annotations);}function composeStory(storyAnnotations,componentAnnotations,projectAnnotations=GLOBAL_STORYBOOK_PROJECT_ANNOTATIONS,defaultConfig={},exportsName){if(storyAnnotations===void 0)throw new Error("Expected a story but received undefined.");componentAnnotations.title=componentAnnotations.title??"ComposedStory";let normalizedComponentAnnotations=normalizeComponentAnnotations(componentAnnotations),storyName=exportsName||storyAnnotations.storyName||storyAnnotations.story?.name||storyAnnotations.name||"unknown",normalizedStory=normalizeStory(storyName,storyAnnotations,normalizedComponentAnnotations),normalizedProjectAnnotations=normalizeProjectAnnotations({...projectAnnotations,...defaultConfig}),story=prepareStory(normalizedStory,normalizedComponentAnnotations,normalizedProjectAnnotations),defaultGlobals=getValuesFromArgTypes(projectAnnotations.globalTypes);return Object.assign(extraArgs=>{let context={...story,hooks:new HooksContext,globals:defaultGlobals,args:{...story.initialArgs,...extraArgs}};return story.unboundStoryFn(prepareContext(context))},{storyName,args:story.initialArgs,play:story.playFunction,parameters:story.parameters,id:story.id})}function composeStories(storiesImport,globalConfig,composeStoryFn){let{default:meta,__esModule,__namedExportsOrder,...stories}=storiesImport;return Object.entries(stories).reduce((storiesMap,[exportsName,story])=>isExportStory(exportsName,meta)?Object.assign(storiesMap,{[exportsName]:composeStoryFn(story,meta,globalConfig,exportsName)}):storiesMap,{})}var CSF_CACHE_SIZE=1e3,STORY_CACHE_SIZE=1e4,EXTRACT_BATCH_SIZE=20,StoryStore=class{constructor(){this.getStoriesJsonData=()=>{let{storyIndex}=this;if(!storyIndex)throw new Error("getStoriesJsonData called before initialization");let value=this.getSetStoriesPayload(),allowedParameters=["fileName","docsOnly","framework","__id","__isArgsStory"];return {v:3,stories:mapValues2(value.stories,story=>{let{importPath}=storyIndex.entries[story.id];return {...pick(story,["id","name","title"]),importPath,kind:story.title,story:story.name,parameters:{...pick(story.parameters,allowedParameters),fileName:importPath}}})}};this.args=new ArgsStore,this.hooks={},this.processCSFFileWithCache=memoize2(CSF_CACHE_SIZE)(processCSFFile),this.prepareMetaWithCache=memoize2(CSF_CACHE_SIZE)(prepareMeta),this.prepareStoryWithCache=memoize2(STORY_CACHE_SIZE)(prepareStory),this.initializationPromise=new SynchronousPromise(resolve=>{this.resolveInitializationPromise=resolve;});}setProjectAnnotations(projectAnnotations){this.projectAnnotations=normalizeProjectAnnotations(projectAnnotations);let{globals,globalTypes}=projectAnnotations;this.globals?this.globals.set({globals,globalTypes}):this.globals=new GlobalsStore({globals,globalTypes});}initialize({storyIndex,importFn,cache=!1}){return this.storyIndex=new StoryIndexStore(storyIndex),this.importFn=importFn,this.resolveInitializationPromise(),cache?this.cacheAllCSFFiles():SynchronousPromise.resolve()}async onStoriesChanged({importFn,storyIndex}){await this.initializationPromise,importFn&&(this.importFn=importFn),storyIndex&&(this.storyIndex.entries=storyIndex.entries),this.cachedCSFFiles&&await this.cacheAllCSFFiles();}async storyIdToEntry(storyId){return await this.initializationPromise,this.storyIndex.storyIdToEntry(storyId)}loadCSFFileByStoryId(storyId){if(!this.storyIndex||!this.importFn)throw new Error("loadCSFFileByStoryId called before initialization");let{importPath,title}=this.storyIndex.storyIdToEntry(storyId);return this.importFn(importPath).then(moduleExports=>this.processCSFFileWithCache(moduleExports,importPath,title))}loadAllCSFFiles({batchSize=EXTRACT_BATCH_SIZE}={}){if(!this.storyIndex)throw new Error("loadAllCSFFiles called before initialization");let importPaths=Object.entries(this.storyIndex.entries).map(([storyId,{importPath}])=>[importPath,storyId]),loadInBatches=remainingImportPaths=>{if(remainingImportPaths.length===0)return SynchronousPromise.resolve([]);let csfFilePromiseList=remainingImportPaths.slice(0,batchSize).map(([importPath,storyId])=>this.loadCSFFileByStoryId(storyId).then(csfFile=>({importPath,csfFile})));return SynchronousPromise.all(csfFilePromiseList).then(firstResults=>loadInBatches(remainingImportPaths.slice(batchSize)).then(restResults=>firstResults.concat(restResults)))};return loadInBatches(importPaths).then(list=>list.reduce((acc,{importPath,csfFile})=>(acc[importPath]=csfFile,acc),{}))}cacheAllCSFFiles(){return this.initializationPromise.then(()=>this.loadAllCSFFiles().then(csfFiles=>{this.cachedCSFFiles=csfFiles;}))}preparedMetaFromCSFFile({csfFile}){if(!this.projectAnnotations)throw new Error("storyFromCSFFile called before initialization");let componentAnnotations=csfFile.meta;return this.prepareMetaWithCache(componentAnnotations,this.projectAnnotations,csfFile.moduleExports.default)}async loadStory({storyId}){await this.initializationPromise;let csfFile=await this.loadCSFFileByStoryId(storyId);return this.storyFromCSFFile({storyId,csfFile})}storyFromCSFFile({storyId,csfFile}){if(!this.projectAnnotations)throw new Error("storyFromCSFFile called before initialization");let storyAnnotations=csfFile.stories[storyId];if(!storyAnnotations)throw new Error(`Didn't find '${storyId}' in CSF file, this is unexpected`);let componentAnnotations=csfFile.meta,story=this.prepareStoryWithCache(storyAnnotations,componentAnnotations,this.projectAnnotations);return this.args.setInitial(story),this.hooks[story.id]=this.hooks[story.id]||new HooksContext,story}componentStoriesFromCSFFile({csfFile}){if(!this.storyIndex)throw new Error("componentStoriesFromCSFFile called before initialization");return Object.keys(this.storyIndex.entries).filter(storyId=>!!csfFile.stories[storyId]).map(storyId=>this.storyFromCSFFile({storyId,csfFile}))}async loadEntry(id){let entry=await this.storyIdToEntry(id),{importFn,storyIndex}=this;if(!storyIndex||!importFn)throw new Error("loadEntry called before initialization");let storyImports=entry.type==="docs"?entry.storiesImports:[],[entryExports,...csfFiles]=await Promise.all([importFn(entry.importPath),...storyImports.map(storyImportPath=>{let firstStoryEntry=storyIndex.importPathToEntry(storyImportPath);return this.loadCSFFileByStoryId(firstStoryEntry.id)})]);return {entryExports,csfFiles}}getStoryContext(story,{forceInitialArgs=!1}={}){if(!this.globals)throw new Error("getStoryContext called before initialization");return prepareContext({...story,args:forceInitialArgs?story.initialArgs:this.args.get(story.id),globals:this.globals.get(),hooks:this.hooks[story.id]})}cleanupStory(story){this.hooks[story.id].clean();}extract(options={includeDocsOnly:!1}){if(!this.storyIndex)throw new Error("extract called before initialization");let{cachedCSFFiles}=this;if(!cachedCSFFiles)throw new Error("Cannot call extract() unless you call cacheAllCSFFiles() first.");return Object.entries(this.storyIndex.entries).reduce((acc,[storyId,{type,importPath}])=>{if(type==="docs")return acc;let csfFile=cachedCSFFiles[importPath],story=this.storyFromCSFFile({storyId,csfFile});return !options.includeDocsOnly&&story.parameters.docsOnly||(acc[storyId]=Object.entries(story).reduce((storyAcc,[key,value])=>key==="moduleExport"||typeof value=="function"?storyAcc:Array.isArray(value)?Object.assign(storyAcc,{[key]:value.slice().sort()}):Object.assign(storyAcc,{[key]:value}),{args:story.initialArgs})),acc},{})}getSetStoriesPayload(){if(!this.globals)throw new Error("getSetStoriesPayload called before initialization");let stories=this.extract({includeDocsOnly:!0}),kindParameters=Object.values(stories).reduce((acc,{title})=>(acc[title]={},acc),{});return {v:2,globals:this.globals.get(),globalParameters:{},kindParameters,stories}}getSetIndexPayload(){if(!this.storyIndex)throw new Error("getSetIndexPayload called before initialization");if(!this.cachedCSFFiles)throw new Error("Cannot call getSetIndexPayload() unless you call cacheAllCSFFiles() first");let{cachedCSFFiles}=this,stories=this.extract({includeDocsOnly:!0});return {v:4,entries:Object.fromEntries(Object.entries(this.storyIndex.entries).map(([id,entry])=>[id,stories[id]?{...entry,args:stories[id].initialArgs,initialArgs:stories[id].initialArgs,argTypes:stories[id].argTypes,parameters:stories[id].parameters}:{...entry,parameters:this.preparedMetaFromCSFFile({csfFile:cachedCSFFiles[entry.importPath]}).parameters}]))}}raw(){return Object.values(this.extract()).map(({id})=>this.fromId(id)).filter(Boolean)}fromId(storyId){if(!this.storyIndex)throw new Error("fromId called before initialization");if(!this.cachedCSFFiles)throw new Error("Cannot call fromId/raw() unless you call cacheAllCSFFiles() first.");let importPath;try{({importPath}=this.storyIndex.storyIdToEntry(storyId));}catch{return null}let csfFile=this.cachedCSFFiles[importPath],story=this.storyFromCSFFile({storyId,csfFile});return {...story,storyFn:update=>{let context={...this.getStoryContext(story),viewMode:"story"};return story.unboundStoryFn({...context,...update})}}}};function useSharedState(sharedId,defaultState){let channel=addons.getChannel(),[lastValue]=channel.last(`${SHARED_STATE_CHANGED}-manager-${sharedId}`)||channel.last(`${SHARED_STATE_SET}-manager-${sharedId}`)||[],[state,setState]=useState(lastValue||defaultState),allListeners=useMemo(()=>({[`${SHARED_STATE_CHANGED}-manager-${sharedId}`]:s=>setState(s),[`${SHARED_STATE_SET}-manager-${sharedId}`]:s=>setState(s)}),[sharedId]),emit=useChannel(allListeners,[sharedId]);return useEffect(()=>{defaultState!==void 0&&!lastValue&&emit(`${SHARED_STATE_SET}-client-${sharedId}`,defaultState);},[sharedId]),[state,s=>{setState(s),emit(`${SHARED_STATE_CHANGED}-client-${sharedId}`,s);}]}function useAddonState(addonId,defaultState){return useSharedState(addonId,defaultState)}function slash(path){return path.startsWith("\\\\?\\")?path:path.replace(/\\/g,"/")}var stripExtension=path=>{let parts=[...path],last=parts[parts.length-1],dotIndex=last.indexOf("."),stripped=dotIndex>0?last.substr(0,dotIndex):last;parts[parts.length-1]=stripped;let[first,...rest]=parts;return first===""&&(parts=rest),parts},indexRe=/^index$/i,removeRedundantFilename=paths=>{let prevVal;return paths.filter((val,index)=>index===paths.length-1&&(val===prevVal||indexRe.test(val))?!1:(prevVal=val,!0))};function pathJoin(paths){let slashes=new RegExp("/{1,}","g");return paths.join("/").replace(slashes,"/")}var userOrAutoTitleFromSpecifier=(fileName,entry,userTitle)=>{let{directory,importPathMatcher,titlePrefix=""}=entry||{};typeof fileName=="number"&&once.warn(dedent`
      CSF Auto-title received a numeric fileName. This typically happens when
      webpack is mis-configured in production mode. To force webpack to produce
      filenames, set optimization.moduleIds = "named" in your webpack config.
    `);let normalizedFileName=slash(String(fileName));if(importPathMatcher.exec(normalizedFileName)){if(!userTitle){let suffix=normalizedFileName.replace(directory,""),path=slash(pathJoin([titlePrefix,suffix])).split("/");return path=stripExtension(path),path=removeRedundantFilename(path),path.join("/")}return titlePrefix?slash(pathJoin([titlePrefix,userTitle])):userTitle}},userOrAutoTitle=(fileName,storiesEntries,userTitle)=>{for(let i=0;i<storiesEntries.length;i+=1){let title=userOrAutoTitleFromSpecifier(fileName,storiesEntries[i],userTitle);if(title)return title}return userTitle||void 0};var STORY_KIND_PATH_SEPARATOR=/\s*\/\s*/,storySort=(options={})=>(a,b)=>{if(a.title===b.title&&!options.includeNames)return 0;let method=options.method||"configure",order=options.order||[],storyTitleA=a.title.trim().split(STORY_KIND_PATH_SEPARATOR),storyTitleB=b.title.trim().split(STORY_KIND_PATH_SEPARATOR);options.includeNames&&(storyTitleA.push(a.name),storyTitleB.push(b.name));let depth=0;for(;storyTitleA[depth]||storyTitleB[depth];){if(!storyTitleA[depth])return -1;if(!storyTitleB[depth])return 1;let nameA=storyTitleA[depth],nameB=storyTitleB[depth];if(nameA!==nameB){let indexA=order.indexOf(nameA),indexB=order.indexOf(nameB),indexWildcard=order.indexOf("*");return indexA!==-1||indexB!==-1?(indexA===-1&&(indexWildcard!==-1?indexA=indexWildcard:indexA=order.length),indexB===-1&&(indexWildcard!==-1?indexB=indexWildcard:indexB=order.length),indexA-indexB):method==="configure"?0:nameA.localeCompare(nameB,options.locales?options.locales:void 0,{numeric:!0,sensitivity:"accent"})}let index=order.indexOf(nameA);index===-1&&(index=order.indexOf("*")),order=index!==-1&&Array.isArray(order[index+1])?order[index+1]:[],depth+=1;}return 0};var sortStoriesCommon=(stories,storySortParameter,fileNameOrder)=>{if(storySortParameter){let sortFn;typeof storySortParameter=="function"?sortFn=storySortParameter:sortFn=storySort(storySortParameter),stories.sort(sortFn);}else stories.sort((s1,s2)=>fileNameOrder.indexOf(s1.importPath)-fileNameOrder.indexOf(s2.importPath));return stories},sortStoriesV7=(stories,storySortParameter,fileNameOrder)=>{try{return sortStoriesCommon(stories,storySortParameter,fileNameOrder)}catch(err){throw new Error(dedent`
    Error sorting stories with sort parameter ${storySortParameter}:

    > ${err.message}
    
    Are you using a V6-style sort function in V7 mode?

    More info: https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#v7-style-story-sort
  `)}},toIndexEntry=story=>{let{id,title,name,parameters,type}=story;return {id,title,name,importPath:parameters.fileName,type}},sortStoriesV6=(stories,storySortParameter,fileNameOrder)=>{if(storySortParameter&&typeof storySortParameter=="function")return stories.sort(storySortParameter),stories.map(s=>toIndexEntry(s[1]));let storiesV7=stories.map(s=>toIndexEntry(s[1]));return sortStoriesCommon(storiesV7,storySortParameter,fileNameOrder)};

export { DEEPLY_EQUAL, StoryStore, UNTARGETED, combineArgs, combineParameters, composeConfigs, composeStepRunners, composeStories, composeStory, decorateStory, deepDiff, defaultDecorateStory, filterArgTypes, getArrayField, getField, getObjectField, getSingletonField, getValuesFromArgTypes, groupArgsByTarget, inferControls, mapArgsToTypes, noTargetArgs, normalizeComponentAnnotations, normalizeInputType, normalizeInputTypes, normalizeProjectAnnotations, normalizeStory, prepareContext, prepareMeta, prepareStory, processCSFFile, sanitizeStoryContextUpdate, setProjectAnnotations, sortStoriesV6, sortStoriesV7, useAddonState, useSharedState, userOrAutoTitle, userOrAutoTitleFromSpecifier, validateOptions };

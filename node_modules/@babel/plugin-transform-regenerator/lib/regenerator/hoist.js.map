{"version":3,"names":["_core","require","hoist","funPath","t","assertFunction","node","vars","__proto__","varDeclToExpr","vdec","includeIdentifiers","assertVariableDeclaration","exprs","declarations","forEach","dec","id","name","identifier","init","push","assignmentExpression","length","sequenceExpression","get","traverse","VariableDeclaration","exit","path","expr","remove","Object","keys","scope","removeBinding","replaceWith","expressionStatement","skip","ForStatement","isVariableDeclaration","ForXStatement","left","FunctionDeclaration","assignment","cloneNode","functionExpression","generateUidIdentifierBasedOnNode","params","body","generator","async","parentPath","isBlockStatement","unshiftContainer","FunctionExpression","ArrowFunctionExpression","paramNames","paramPath","param","isIdentifier","hasOwnProperty","call","variableDeclarator"],"sources":["../../src/regenerator/hoist.ts"],"sourcesContent":["import type { NodePath } from \"@babel/core\";\nimport { types as t } from \"@babel/core\";\n\n// The hoist function takes a FunctionExpression or FunctionDeclaration\n// and replaces any Declaration nodes in its body with assignments, then\n// returns a VariableDeclaration containing just the names of the removed\n// declarations.\nexport function hoist(\n  funPath: NodePath<t.FunctionExpression | t.FunctionDeclaration>,\n) {\n  t.assertFunction(funPath.node);\n\n  const vars: Record<string, t.Identifier> = { __proto__: null };\n\n  function varDeclToExpr(\n    { node: vdec }: NodePath,\n    includeIdentifiers: boolean,\n  ) {\n    t.assertVariableDeclaration(vdec);\n    // TODO assert.equal(vdec.kind, \"var\");\n    const exprs: t.Expression[] = [];\n\n    vdec.declarations.forEach(function (\n      dec: t.VariableDeclarator & { id: t.Identifier },\n    ) {\n      // Note: We duplicate 'dec.id' here to ensure that the variable declaration IDs don't\n      // have the same 'loc' value, since that can make sourcemaps and retainLines behave poorly.\n      vars[dec.id.name] = t.identifier(dec.id.name);\n\n      if (dec.init) {\n        exprs.push(t.assignmentExpression(\"=\", dec.id, dec.init));\n      } else if (includeIdentifiers) {\n        exprs.push(dec.id);\n      }\n    });\n\n    if (exprs.length === 0) return null;\n\n    if (exprs.length === 1) return exprs[0];\n\n    return t.sequenceExpression(exprs);\n  }\n\n  funPath.get(\"body\").traverse({\n    VariableDeclaration: {\n      exit: function (path) {\n        const expr = varDeclToExpr(path, false);\n        if (expr === null) {\n          path.remove();\n        } else {\n          for (const name of Object.keys(vars)) {\n            // Remove the binding, to avoid \"duplicate declaration\" errors when it will\n            // be injected again.\n            path.scope.removeBinding(name);\n          }\n\n          // We don't need to traverse this expression any further because\n          // there can't be any new declarations inside an expression.\n          path.replaceWith(t.expressionStatement(expr));\n        }\n\n        // Since the original node has been either removed or replaced,\n        // avoid traversing it any further.\n        path.skip();\n      },\n    },\n\n    ForStatement: function (path) {\n      const init = path.get(\"init\");\n      if (init.isVariableDeclaration()) {\n        const expr = varDeclToExpr(init, false);\n        if (expr) {\n          init.replaceWith(expr);\n        } else {\n          init.remove();\n        }\n      }\n    },\n\n    ForXStatement: function (path) {\n      const left = path.get(\"left\");\n      if (left.isVariableDeclaration()) {\n        left.replaceWith(varDeclToExpr(left, true));\n      }\n    },\n\n    FunctionDeclaration: function (path) {\n      const node = path.node;\n      vars[node.id.name] = node.id;\n\n      const assignment = t.expressionStatement(\n        t.assignmentExpression(\n          \"=\",\n          t.cloneNode(node.id),\n          t.functionExpression(\n            path.scope.generateUidIdentifierBasedOnNode(node),\n            node.params,\n            node.body,\n            node.generator,\n            node.async,\n          ),\n        ),\n      );\n\n      if (path.parentPath.isBlockStatement()) {\n        // Insert the assignment form before the first statement in the\n        // enclosing block.\n        path.parentPath.unshiftContainer(\"body\", assignment);\n\n        // Remove the function declaration now that we've inserted the\n        // equivalent assignment form at the beginning of the block.\n        path.remove();\n      } else {\n        // If the parent node is not a block statement, then we can just\n        // replace the declaration with the equivalent assignment form\n        // without worrying about hoisting it.\n        path.replaceWith(assignment);\n\n        // Remove the binding, to avoid \"duplicate declaration\" errors when it will\n        // be injected again.\n        path.scope.removeBinding(node.id.name);\n      }\n\n      // Don't hoist variables out of inner functions.\n      path.skip();\n    },\n\n    FunctionExpression: function (path) {\n      // Don't descend into nested function expressions.\n      path.skip();\n    },\n\n    ArrowFunctionExpression: function (path) {\n      // Don't descend into nested function expressions.\n      path.skip();\n    },\n  });\n\n  const paramNames: Record<string, t.Identifier> = { __proto__: null };\n  funPath.get(\"params\").forEach(function (paramPath) {\n    const param = paramPath.node;\n    if (t.isIdentifier(param)) {\n      paramNames[param.name] = param;\n    } else {\n      // Variables declared by destructuring parameter patterns will be\n      // harmlessly re-declared.\n    }\n  });\n\n  const declarations: t.VariableDeclarator[] = [];\n\n  Object.keys(vars).forEach(function (name) {\n    if (!Object.hasOwn(paramNames, name)) {\n      declarations.push(t.variableDeclarator(vars[name], null));\n    }\n  });\n\n  return declarations;\n}\n"],"mappings":"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","ignoreList":[]}
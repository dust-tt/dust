{"version":3,"file":"index.js","sources":["../src/shouldStoreRHSInTemporaryVariable.ts","../src/compat-data.ts","../src/index.ts"],"sourcesContent":["import type { types as t } from \"@babel/core\";\n\n/**\n * This is a helper function to determine if we should create an intermediate variable\n * such that the RHS of an assignment is not duplicated.\n *\n * See https://github.com/babel/babel/pull/13711#issuecomment-914388382 for discussion\n * on further optimizations.\n */\nexport default function shouldStoreRHSInTemporaryVariable(\n  node: t.LVal | t.PatternLike,\n): boolean {\n  if (!node) return false;\n  if (node.type === \"ArrayPattern\") {\n    const nonNullElements = node.elements.filter(\n      (element): element is Exclude<(typeof node.elements)[0], t.VoidPattern> =>\n        element !== null && element.type !== \"VoidPattern\",\n    );\n    if (nonNullElements.length > 1) return true;\n    else return shouldStoreRHSInTemporaryVariable(nonNullElements[0]);\n  } else if (node.type === \"ObjectPattern\") {\n    const { properties } = node;\n    if (properties.length > 1) return true;\n    else if (properties.length === 0) return false;\n    else {\n      const firstProperty = properties[0];\n      if (firstProperty.type === \"ObjectProperty\") {\n        // the value of the property must be an LVal\n        return shouldStoreRHSInTemporaryVariable(firstProperty.value as t.LVal);\n      } else {\n        return shouldStoreRHSInTemporaryVariable(firstProperty);\n      }\n    }\n  } else if (node.type === \"AssignmentPattern\") {\n    return shouldStoreRHSInTemporaryVariable(node.left);\n  } else if (node.type === \"RestElement\") {\n    if (node.argument.type === \"Identifier\") return true;\n    return shouldStoreRHSInTemporaryVariable(node.argument);\n  } else {\n    // node is Identifier or MemberExpression\n    return false;\n  }\n}\n","export default {\n  \"Object.assign\": {\n    chrome: \"49\",\n    opera: \"36\",\n    edge: \"13\",\n    firefox: \"36\",\n    safari: \"10\",\n    node: \"6\",\n    deno: \"1\",\n    ios: \"10\",\n    samsung: \"5\",\n    opera_mobile: \"36\",\n    electron: \"0.37\",\n  },\n};\n","import { declare } from \"@babel/helper-plugin-utils\";\nimport { types as t } from \"@babel/core\";\nimport type { PluginPass, NodePath, Scope } from \"@babel/core\";\nimport { convertFunctionParams } from \"@babel/plugin-transform-parameters\";\nimport { isRequired } from \"@babel/helper-compilation-targets\";\nimport shouldStoreRHSInTemporaryVariable from \"./shouldStoreRHSInTemporaryVariable.ts\";\nimport compatData from \"./compat-data.ts\";\nimport { unshiftForXStatementBody } from \"@babel/plugin-transform-destructuring\";\n\n// @babel/types <=7.3.3 counts FOO as referenced in var { x: FOO }.\n// We need to detect this bug to know if \"unused\" means 0 or 1 references.\nif (!process.env.BABEL_8_BREAKING) {\n  const node = t.identifier(\"a\");\n  const property = t.objectProperty(t.identifier(\"key\"), node);\n  const pattern = t.objectPattern([property]);\n\n  // eslint-disable-next-line no-var\n  var ZERO_REFS = t.isReferenced(node, property, pattern) ? 1 : 0;\n}\n\nexport interface Options {\n  useBuiltIns?: boolean;\n  loose?: boolean;\n}\n\nexport default declare((api, opts: Options) => {\n  api.assertVersion(REQUIRED_VERSION(\"^7.0.0-0 || ^8.0.0-0\"));\n\n  const targets = api.targets();\n  const supportsObjectAssign = !isRequired(\"Object.assign\", targets, {\n    compatData,\n  });\n\n  const { useBuiltIns = supportsObjectAssign, loose = false } = opts;\n\n  if (typeof loose !== \"boolean\") {\n    throw new Error(\".loose must be a boolean, or undefined\");\n  }\n\n  const ignoreFunctionLength = api.assumption(\"ignoreFunctionLength\") ?? loose;\n  const objectRestNoSymbols = api.assumption(\"objectRestNoSymbols\") ?? loose;\n  const pureGetters = api.assumption(\"pureGetters\") ?? loose;\n  const setSpreadProperties = api.assumption(\"setSpreadProperties\") ?? loose;\n\n  function getExtendsHelper(\n    file: PluginPass,\n  ): t.MemberExpression | t.Identifier {\n    return useBuiltIns\n      ? t.memberExpression(t.identifier(\"Object\"), t.identifier(\"assign\"))\n      : file.addHelper(\"extends\");\n  }\n\n  function* iterateObjectRestElement(\n    path: NodePath<t.LVal | t.PatternLike | t.TSParameterProperty>,\n  ): Generator<NodePath<t.RestElement>> {\n    switch (path.type) {\n      case \"ArrayPattern\":\n        for (const elementPath of path.get(\"elements\")) {\n          if (elementPath.isRestElement()) {\n            yield* iterateObjectRestElement(elementPath.get(\"argument\"));\n          } else {\n            yield* iterateObjectRestElement(elementPath);\n          }\n        }\n        break;\n      case \"ObjectPattern\":\n        for (const propertyPath of path.get(\"properties\")) {\n          if (propertyPath.isRestElement()) {\n            yield propertyPath;\n          } else {\n            yield* iterateObjectRestElement(\n              propertyPath.get(\"value\") as NodePath<t.Pattern>,\n            );\n          }\n        }\n        break;\n      case \"AssignmentPattern\":\n        yield* iterateObjectRestElement(path.get(\"left\"));\n        break;\n      default:\n        break;\n    }\n  }\n\n  function hasObjectRestElement(\n    path: NodePath<t.LVal | t.PatternLike | t.TSParameterProperty>,\n  ): boolean {\n    const objectRestPatternIterator = iterateObjectRestElement(path);\n    return !objectRestPatternIterator.next().done;\n  }\n\n  function visitObjectRestElements(\n    path: NodePath<t.LVal | t.PatternLike>,\n    visitor: (path: NodePath<t.RestElement>) => void,\n  ) {\n    for (const restElementPath of iterateObjectRestElement(path)) {\n      visitor(restElementPath);\n    }\n  }\n\n  function hasSpread(node: t.ObjectExpression): boolean {\n    for (const prop of node.properties) {\n      if (t.isSpreadElement(prop)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  // returns an array of all keys of an object, and a status flag indicating if all extracted keys\n  // were converted to stringLiterals or not\n  // e.g. extracts {keys: [\"a\", \"b\", \"3\", ++x], allPrimitives: false }\n  // from ast of {a: \"foo\", b, 3: \"bar\", [++x]: \"baz\"}\n  // `allPrimitives: false` doesn't necessarily mean that there is a non-primitive, but just\n  // that we are not sure.\n  function extractNormalizedKeys(pattern: NodePath<t.ObjectPattern>) {\n    // RestElement has been removed in createObjectRest\n    const propsList: t.ObjectProperty[] = pattern\n      .get(\"properties\")\n      .map((p: NodePath) => p.node as t.ObjectProperty);\n\n    const keys: t.Expression[] = [];\n    let allPrimitives = true;\n    let hasTemplateLiteral = false;\n\n    for (const prop of propsList) {\n      const key = prop.key;\n      if (t.isIdentifier(key) && !prop.computed) {\n        // since a key {a: 3} is equivalent to {\"a\": 3}, use the latter\n        keys.push(t.stringLiteral(key.name));\n      } else if (t.isTemplateLiteral(key)) {\n        keys.push(t.cloneNode(key));\n        hasTemplateLiteral = true;\n      } else if (t.isLiteral(key)) {\n        keys.push(\n          t.stringLiteral(\n            String(\n              // @ts-expect-error prop.key can not be a NullLiteral\n              key.value,\n            ),\n          ),\n        );\n      } else {\n        // If the key is an inline memoization assignment (e.g. _key = expr),\n        // use just the identifier part for the exclusion array\n        if (t.isAssignmentExpression(key) && t.isIdentifier(key.left)) {\n          // For inline memoized keys, use just the left side (the identifier)\n          // to avoid evaluating the assignment expression multiple times\n          keys.push(t.cloneNode(key.left));\n        } else {\n          // @ts-expect-error private name has been handled by destructuring-private\n          keys.push(t.cloneNode(key));\n        }\n\n        // Check the original key for primitiveness\n        const keyToCheck = t.isAssignmentExpression(key) ? key.right : key;\n        if (\n          (t.isMemberExpression(keyToCheck, { computed: false }) &&\n            t.isIdentifier(keyToCheck.object, { name: \"Symbol\" })) ||\n          (t.isCallExpression(keyToCheck) &&\n            t.matchesPattern(keyToCheck.callee, \"Symbol.for\"))\n        ) {\n          // there all return a primitive\n        } else {\n          allPrimitives = false;\n        }\n      }\n    }\n\n    return { keys, allPrimitives, hasTemplateLiteral };\n  }\n\n  /**\n   * Replaces computed keys that have side effects with inline memoization.\n   *\n   * Example: { [foo()]: x } becomes { [_temp = foo()]: x } with upfront declaration: var _temp;\n   *\n   * This function is called in multiple places during transformation. To avoid creating\n   * duplicate temp variables, we skip properties that were already memoized inline by\n   * checking if the key is an assignment expression with a UID identifier.\n   */\n  function replaceImpureComputedKeys(\n    properties: NodePath<t.ObjectProperty>[],\n    scope: Scope,\n  ) {\n    const tempVariableDeclarations: t.VariableDeclarator[] = [];\n\n    for (const property of properties) {\n      // PrivateName is handled in destructuring-private plugin\n      const keyExpression = property.get(\"key\") as NodePath<t.Expression>;\n\n      // Skip if already memoised (inline assignment expression with a UID)\n      // This happens when inline memoization is used for nested object rest\n      if (\n        keyExpression.isAssignmentExpression() &&\n        keyExpression.get(\"left\").isIdentifier()\n      ) {\n        const identName = (keyExpression.node.left as t.Identifier).name;\n        // Check if it's a UID (hasUid already searches parent scopes)\n        if (scope.hasUid(identName)) {\n          continue;\n        }\n      }\n\n      // Only process computed keys that have side effects (function calls, mutations, etc.)\n      if (property.node.computed && !keyExpression.isPure()) {\n        const tempVariableName = scope.generateUidBasedOnNode(\n          keyExpression.node,\n        );\n        const tempVariableDeclaration = t.variableDeclarator(\n          t.identifier(tempVariableName),\n          keyExpression.node,\n        );\n        tempVariableDeclarations.push(tempVariableDeclaration);\n        keyExpression.replaceWith(t.identifier(tempVariableName));\n      }\n    }\n\n    return tempVariableDeclarations;\n  }\n\n  function removeUnusedExcludedKeys(path: NodePath<t.ObjectPattern>): void {\n    const bindings = path.getOuterBindingIdentifierPaths();\n\n    Object.keys(bindings).forEach(bindingName => {\n      const bindingParentPath = bindings[bindingName].parentPath;\n      if (\n        path.scope.getBinding(bindingName).references >\n          (process.env.BABEL_8_BREAKING ? 0 : ZERO_REFS) ||\n        !bindingParentPath.isObjectProperty()\n      ) {\n        return;\n      }\n      bindingParentPath.remove();\n    });\n  }\n\n  /**\n   * Finds all computed property keys in a destructuring pattern,\n   * in the order they appear in the source code.\n   *\n   * Example: const { [a()]: { [b()]: x, ...rest }, [c()]: y } = obj\n   * Returns: [a(), b(), c()] in that order\n   *\n   * This is needed because when nested patterns have rest elements (...rest),\n   * the transformation splits them up, but need to ensure a(), b(), c()\n   * are always evaluated in this exact order (left-to-right as written).\n   */\n  function collectComputedKeysInSourceOrder(\n    destructuringPattern: NodePath<t.ObjectPattern>,\n  ): NodePath<t.ObjectProperty>[] {\n    const computedProperties: NodePath<t.ObjectProperty>[] = [];\n\n    function visitPattern(pattern: NodePath<t.PatternLike | t.LVal>) {\n      if (pattern.isObjectPattern()) {\n        const properties = pattern.get(\"properties\") as NodePath<\n          t.ObjectProperty | t.RestElement\n        >[];\n        for (const property of properties) {\n          if (property.isRestElement()) continue;\n\n          // If this property has a computed key like [someExpression], collect it\n          if (property.node.computed) {\n            computedProperties.push(property);\n          }\n\n          // Then look inside the property's value for more nested patterns\n          const nestedPattern = property.get(\n            \"value\",\n          ) as NodePath<t.PatternLike>;\n          visitPattern(nestedPattern as NodePath<t.PatternLike | t.LVal>);\n        }\n      } else if (pattern.isArrayPattern()) {\n        for (const element of pattern.get(\"elements\")) {\n          if (!element) continue;\n          if (element.isRestElement()) {\n            const restArgument = element.get(\"argument\") as NodePath<\n              t.PatternLike | t.LVal\n            >;\n            visitPattern(restArgument);\n          } else {\n            visitPattern(element as NodePath<t.PatternLike | t.LVal>);\n          }\n        }\n      } else if (pattern.isAssignmentPattern()) {\n        visitPattern(pattern.get(\"left\") as NodePath<t.PatternLike | t.LVal>);\n      }\n    }\n\n    visitPattern(\n      destructuringPattern as unknown as NodePath<t.PatternLike | t.LVal>,\n    );\n    return computedProperties;\n  }\n\n  //expects path to an object pattern\n  function createObjectRest(\n    path: NodePath<t.ObjectPattern>,\n    file: PluginPass,\n    objRef: t.Identifier | t.MemberExpression,\n  ): [\n    t.VariableDeclarator[],\n    t.AssignmentExpression[\"left\"],\n    t.CallExpression,\n  ] {\n    const props = path.get(\"properties\");\n    const last = props[props.length - 1];\n    t.assertRestElement(last.node);\n    const restElement = t.cloneNode(last.node);\n    last.remove();\n\n    const impureComputedPropertyDeclarators = replaceImpureComputedKeys(\n      path.get(\"properties\") as NodePath<t.ObjectProperty>[],\n      path.scope,\n    );\n    const { keys, allPrimitives, hasTemplateLiteral } =\n      extractNormalizedKeys(path);\n\n    if (keys.length === 0) {\n      return [\n        impureComputedPropertyDeclarators,\n        restElement.argument,\n        t.callExpression(getExtendsHelper(file), [\n          t.objectExpression([]),\n          t.sequenceExpression([\n            t.callExpression(file.addHelper(\"objectDestructuringEmpty\"), [\n              t.cloneNode(objRef),\n            ]),\n            t.cloneNode(objRef),\n          ]),\n        ]),\n      ];\n    }\n\n    let keyExpression;\n    if (!allPrimitives) {\n      // map to toPropertyKey to handle the possible non-string values\n      keyExpression = t.callExpression(\n        t.memberExpression(t.arrayExpression(keys), t.identifier(\"map\")),\n        [file.addHelper(\"toPropertyKey\")],\n      );\n    } else {\n      keyExpression = t.arrayExpression(keys);\n\n      if (!hasTemplateLiteral && !t.isProgram(path.scope.block)) {\n        // Hoist definition of excluded keys, so that it's not created each time.\n        const program = path.findParent(path => path.isProgram());\n        const id = path.scope.generateUidIdentifier(\"excluded\");\n\n        program.scope.push({\n          id,\n          init: keyExpression,\n          kind: \"const\",\n        });\n\n        keyExpression = t.cloneNode(id);\n      }\n    }\n\n    return [\n      impureComputedPropertyDeclarators,\n      restElement.argument,\n      t.callExpression(\n        file.addHelper(\n          `objectWithoutProperties${objectRestNoSymbols ? \"Loose\" : \"\"}`,\n        ),\n        [t.cloneNode(objRef), keyExpression],\n      ),\n    ];\n  }\n\n  function replaceRestElement(\n    parentPath: NodePath<t.Function | t.CatchClause>,\n    paramPath: NodePath<\n      t.Function[\"params\"][number] | t.AssignmentPattern[\"left\"]\n    >,\n    container?: t.VariableDeclaration[],\n  ): void {\n    if (paramPath.isAssignmentPattern()) {\n      replaceRestElement(parentPath, paramPath.get(\"left\"), container);\n      return;\n    }\n\n    if (paramPath.isArrayPattern() && hasObjectRestElement(paramPath)) {\n      const elements = paramPath.get(\"elements\");\n\n      for (let i = 0; i < elements.length; i++) {\n        replaceRestElement(parentPath, elements[i], container);\n      }\n    }\n\n    if (paramPath.isObjectPattern() && hasObjectRestElement(paramPath)) {\n      const uid = parentPath.scope.generateUidIdentifier(\"ref\");\n\n      const declar = t.variableDeclaration(\"let\", [\n        t.variableDeclarator(paramPath.node, uid),\n      ]);\n\n      if (container) {\n        container.push(declar);\n      } else {\n        parentPath.ensureBlock();\n        (parentPath.get(\"body\") as NodePath<t.BlockStatement>).unshiftContainer(\n          \"body\",\n          declar,\n        );\n      }\n      paramPath.replaceWith(t.cloneNode(uid));\n    }\n  }\n\n  return {\n    name: \"transform-object-rest-spread\",\n    manipulateOptions: process.env.BABEL_8_BREAKING\n      ? undefined\n      : (_, parser) => parser.plugins.push(\"objectRestSpread\"),\n\n    visitor: {\n      // function a({ b, ...c }) {}\n      Function(path) {\n        const params = path.get(\"params\");\n        const paramsWithRestElement = new Set<number>();\n        const idsInRestParams = new Set();\n        for (let i = 0; i < params.length; ++i) {\n          const param = params[i];\n          if (hasObjectRestElement(param)) {\n            paramsWithRestElement.add(i);\n            for (const name of Object.keys(param.getBindingIdentifiers())) {\n              idsInRestParams.add(name);\n            }\n          }\n        }\n\n        // if true, a parameter exists that has an id in its initializer\n        // that is also an id bound in a rest parameter\n        // example: f({...R}, a = R)\n        let idInRest = false;\n\n        const IdentifierHandler = function (\n          path: NodePath<t.Identifier>,\n          functionScope: Scope,\n        ) {\n          const name = path.node.name;\n          if (\n            path.scope.getBinding(name) === functionScope.getBinding(name) &&\n            idsInRestParams.has(name)\n          ) {\n            idInRest = true;\n            path.stop();\n          }\n        };\n\n        let i: number;\n        for (i = 0; i < params.length && !idInRest; ++i) {\n          const param = params[i];\n          if (!paramsWithRestElement.has(i)) {\n            if (param.isReferencedIdentifier() || param.isBindingIdentifier()) {\n              IdentifierHandler(param, path.scope);\n            } else {\n              param.traverse(\n                {\n                  \"Scope|TypeAnnotation|TSTypeAnnotation\": path => path.skip(),\n                  \"ReferencedIdentifier|BindingIdentifier\": IdentifierHandler,\n                },\n                path.scope,\n              );\n            }\n          }\n        }\n\n        if (!idInRest) {\n          for (let i = 0; i < params.length; ++i) {\n            const param = params[i];\n            if (paramsWithRestElement.has(i)) {\n              replaceRestElement(path, param);\n            }\n          }\n        } else {\n          const shouldTransformParam = (idx: number) =>\n            idx >= i - 1 || paramsWithRestElement.has(idx);\n          convertFunctionParams(\n            path,\n            ignoreFunctionLength,\n            shouldTransformParam,\n            replaceRestElement,\n          );\n        }\n      },\n\n      // adapted from transform-destructuring/src/index.js#pushObjectRest\n      // const { a, ...b } = c;\n      VariableDeclarator(path, file) {\n        if (!path.get(\"id\").isObjectPattern()) {\n          return;\n        }\n\n        let insertionPath = path;\n        const originalPath = path;\n\n        /**\n         * Fix for: https://github.com/babel/babel/issues/17274\n         *\n         * Problem: When you have nested destructuring with computed keys and rest elements:\n         *   const { [log(0)]: { [log(1)]: x, ...rest }, [log(2)]: y } = obj\n         *\n         * The functions log(0), log(1), log(2) must be called in that exact order.\n         * But without this fix, the nested pattern gets processed first, causing the wrong order.\n         *\n         * Additionally, with default values:\n         *   const { [log(0)]: x = log(1), [log(2)]: y } = obj\n         *\n         * The order must be: log(0), then log(1) (if x is undefined), then log(2).\n         *\n         * Solution: Use inline memoization with assignment expressions.\n         * Transform:\n         *   const { [log(0)]: { [log(1)]: x, ...rest }, [log(2)]: y } = obj\n         * Into:\n         *   var _log, _log2, _log3;\n         *   const { [_log = log(0)]: { [_log2 = log(1)]: x, ...rest }, [_log3 = log(2)]: y } = obj\n         *\n         * This preserves correct evaluation order even with default values.\n         */\n\n        // Only memoize computed keys if there are rest elements that require this fix\n        if (hasObjectRestElement(path.get(\"id\"))) {\n          // Find all computed keys (like [someExpression]) in left-to-right order\n          const destructuringPattern = originalPath.get(\n            \"id\",\n          ) as NodePath<t.ObjectPattern>;\n          const propertiesWithComputedKeys =\n            collectComputedKeysInSourceOrder(destructuringPattern);\n\n          // For each computed key that has side effects (not a simple variable)\n          for (const property of propertiesWithComputedKeys) {\n            const computedKeyExpression = property.get(\n              \"key\",\n            ) as NodePath<t.Expression>;\n\n            // Skip if already memoised (assignment expression with a UID)\n            if (\n              computedKeyExpression.isAssignmentExpression() &&\n              computedKeyExpression.get(\"left\").isIdentifier() &&\n              originalPath.scope.hasUid(\n                (computedKeyExpression.node.left as t.Identifier).name,\n              )\n            ) {\n              continue;\n            }\n\n            // Check if the expression has side effects (function call, ++x, etc.)\n            if (!computedKeyExpression.isPure()) {\n              // Create a temporary variable identifier\n              const tempVariableName =\n                originalPath.scope.generateUidBasedOnNode(\n                  computedKeyExpression.node,\n                );\n              const tempIdentifier = t.identifier(tempVariableName);\n\n              // Declare the variable upfront with no initializer (var declaration)\n              originalPath.scope.push({\n                id: tempIdentifier,\n                kind: \"var\",\n              });\n\n              // Replace [log(0)] with [_key = log(0)] for inline memoization\n              computedKeyExpression.replaceWith(\n                t.assignmentExpression(\n                  \"=\",\n                  t.cloneNode(tempIdentifier),\n                  computedKeyExpression.node,\n                ),\n              );\n            }\n          }\n        }\n\n        visitObjectRestElements(path.get(\"id\"), path => {\n          if (\n            // skip single-property case, e.g.\n            // const { ...x } = foo();\n            // since the RHS will not be duplicated\n            shouldStoreRHSInTemporaryVariable(originalPath.node.id) &&\n            !t.isIdentifier(originalPath.node.init)\n          ) {\n            // const { a, ...b } = foo();\n            // to avoid calling foo() twice, as a first step convert it to:\n            // const _foo = foo(),\n            //       { a, ...b } = _foo;\n            const initRef = path.scope.generateUidIdentifierBasedOnNode(\n              originalPath.node.init,\n              \"ref\",\n            );\n            // insert _foo = foo()\n            originalPath.insertBefore(\n              t.variableDeclarator(initRef, originalPath.node.init),\n            );\n            // replace foo() with _foo\n            originalPath.replaceWith(\n              t.variableDeclarator(originalPath.node.id, t.cloneNode(initRef)),\n            );\n\n            return;\n          }\n\n          let ref = originalPath.node.init;\n          const refPropertyPath: NodePath<t.ObjectProperty>[] = [];\n          let kind;\n\n          path.findParent((path: NodePath): boolean => {\n            if (path.isObjectProperty()) {\n              refPropertyPath.unshift(path);\n            } else if (path.isVariableDeclarator()) {\n              kind = path.parentPath.node.kind;\n              return true;\n            }\n          });\n\n          const impureObjRefComputedDeclarators = replaceImpureComputedKeys(\n            refPropertyPath,\n            path.scope,\n          );\n          refPropertyPath.forEach(prop => {\n            // Get the current key (which may have been transformed to an inline assignment)\n            const keyPath = prop.get(\"key\") as NodePath<t.Expression>;\n            let keyForMemberExpression: t.Expression = keyPath.node;\n\n            // If the key is an inline memoization assignment, use just the identifier\n            if (t.isAssignmentExpression(keyPath.node)) {\n              // For inline memoized keys, extract just the left side (the identifier)\n              // to avoid re-evaluating the assignment expression\n              keyForMemberExpression = keyPath.node.left as t.Expression;\n            }\n\n            ref = t.memberExpression(\n              ref,\n              t.cloneNode(keyForMemberExpression),\n              prop.node.computed || t.isLiteral(keyPath.node),\n            );\n          });\n\n          const objectPatternPath =\n            path.parentPath as NodePath<t.ObjectPattern>;\n\n          const [impureComputedPropertyDeclarators, argument, callExpression] =\n            createObjectRest(\n              objectPatternPath,\n              file,\n              ref as t.MemberExpression,\n            );\n\n          if (pureGetters) {\n            removeUnusedExcludedKeys(objectPatternPath);\n          }\n\n          t.assertIdentifier(argument);\n\n          insertionPath.insertBefore(impureComputedPropertyDeclarators);\n\n          insertionPath.insertBefore(impureObjRefComputedDeclarators);\n\n          insertionPath = insertionPath.insertAfter(\n            t.variableDeclarator(argument, callExpression),\n          )[0];\n\n          path.scope.registerBinding(kind, insertionPath);\n\n          if (objectPatternPath.node.properties.length === 0) {\n            objectPatternPath\n              .findParent(\n                path => path.isObjectProperty() || path.isVariableDeclarator(),\n              )\n              .remove();\n          }\n        });\n      },\n\n      // taken from transform-destructuring/src/index.js#visitor\n      // export var { a, ...b } = c;\n      ExportNamedDeclaration(path) {\n        const declaration = path.get(\"declaration\");\n        if (!declaration.isVariableDeclaration()) return;\n\n        const hasRest = declaration\n          .get(\"declarations\")\n          .some(path => hasObjectRestElement(path.get(\"id\")));\n        if (!hasRest) return;\n\n        // Split the declaration and export list into two declarations so that the variable\n        // declaration can be split up later without needing to worry about not being a\n        // top-level statement.\n        if (!process.env.BABEL_8_BREAKING && !USE_ESM && !IS_STANDALONE) {\n          // polyfill when being run by an older Babel version\n          path.splitExportDeclaration ??=\n            // eslint-disable-next-line no-restricted-globals\n            require(\"@babel/traverse\").NodePath.prototype.splitExportDeclaration;\n        }\n        path.splitExportDeclaration();\n      },\n\n      // try {} catch ({a, ...b}) {}\n      CatchClause(path) {\n        const paramPath = path.get(\"param\");\n        replaceRestElement(path, paramPath);\n      },\n\n      // ({a, ...b} = c);\n      AssignmentExpression(path, file) {\n        const leftPath = path.get(\"left\");\n        if (leftPath.isObjectPattern() && hasObjectRestElement(leftPath)) {\n          const nodes = [];\n\n          const refName = path.scope.generateUidBasedOnNode(\n            path.node.right,\n            \"ref\",\n          );\n\n          nodes.push(\n            t.variableDeclaration(\"var\", [\n              t.variableDeclarator(t.identifier(refName), path.node.right),\n            ]),\n          );\n\n          const [impureComputedPropertyDeclarators, argument, callExpression] =\n            createObjectRest(leftPath, file, t.identifier(refName));\n\n          if (impureComputedPropertyDeclarators.length > 0) {\n            nodes.push(\n              t.variableDeclaration(\"var\", impureComputedPropertyDeclarators),\n            );\n          }\n\n          const nodeWithoutSpread = t.cloneNode(path.node);\n          nodeWithoutSpread.right = t.identifier(refName);\n          nodes.push(t.expressionStatement(nodeWithoutSpread));\n          nodes.push(\n            t.expressionStatement(\n              t.assignmentExpression(\"=\", argument, callExpression),\n            ),\n          );\n          nodes.push(t.expressionStatement(t.identifier(refName)));\n\n          path.replaceWithMultiple(nodes);\n        }\n      },\n\n      // taken from transform-destructuring/src/index.js#visitor\n      ForXStatement(path: NodePath<t.ForXStatement>) {\n        const { node, scope } = path;\n        const leftPath = path.get(\"left\");\n\n        if (!leftPath.isVariableDeclaration()) {\n          if (!hasObjectRestElement(leftPath)) {\n            return;\n          }\n          // for ({a, ...b} of []) {}\n          const temp = scope.generateUidIdentifier(\"ref\");\n\n          node.left = t.variableDeclaration(\"var\", [\n            t.variableDeclarator(temp),\n          ]);\n\n          path.ensureBlock();\n\n          const statementBody = (path.node.body as t.BlockStatement).body;\n          const nodes = [];\n          // todo: the completion of a for statement can only be observed from\n          // a do block (or eval that we don't support),\n          // but the new do-expression proposal plans to ban iteration ends in the\n          // do block, maybe we can get rid of this\n          if (statementBody.length === 0 && path.isCompletionRecord()) {\n            nodes.unshift(t.expressionStatement(scope.buildUndefinedNode()));\n          }\n\n          nodes.unshift(\n            t.expressionStatement(\n              t.assignmentExpression(\"=\", leftPath.node, t.cloneNode(temp)),\n            ),\n          );\n\n          unshiftForXStatementBody(path, nodes);\n          scope.crawl();\n          return;\n        } else {\n          // for (var {a, ...b} of []) {}\n          const patternPath = leftPath.get(\"declarations\")[0].get(\"id\");\n          if (!hasObjectRestElement(patternPath)) {\n            return;\n          }\n          const left = leftPath.node;\n          const pattern = patternPath.node;\n\n          const key = scope.generateUidIdentifier(\"ref\");\n          node.left = t.variableDeclaration(left.kind, [\n            t.variableDeclarator(key, null),\n          ]);\n\n          path.ensureBlock();\n\n          unshiftForXStatementBody(path, [\n            t.variableDeclaration(node.left.kind, [\n              t.variableDeclarator(pattern, t.cloneNode(key)),\n            ]),\n          ]);\n          scope.crawl();\n          return;\n        }\n      },\n\n      // [{a, ...b}] = c;\n      ArrayPattern(path) {\n        type LhsAndRhs = { left: t.ObjectPattern; right: t.Identifier };\n        const objectPatterns: LhsAndRhs[] = [];\n        const { scope } = path;\n        const uidIdentifiers: t.Identifier[] = [];\n\n        visitObjectRestElements(path, path => {\n          const objectPattern = path.parentPath as NodePath<t.ObjectPattern>;\n\n          const uid = scope.generateUidIdentifier(\"ref\");\n          objectPatterns.push({ left: objectPattern.node, right: uid });\n          uidIdentifiers.push(uid);\n\n          objectPattern.replaceWith(t.cloneNode(uid));\n          path.skip();\n        });\n\n        if (objectPatterns.length > 0) {\n          const patternParentPath = path.findParent(\n            path => !(path.isPattern() || path.isObjectProperty()),\n          );\n          const patternParent = patternParentPath.node;\n          switch (patternParent.type) {\n            case \"VariableDeclarator\":\n              patternParentPath.insertAfter(\n                objectPatterns.map(({ left, right }) =>\n                  t.variableDeclarator(left, right),\n                ),\n              );\n              break;\n            case \"AssignmentExpression\":\n              {\n                for (const uidIdentifier of uidIdentifiers) {\n                  scope.push({ id: t.cloneNode(uidIdentifier) });\n                }\n                patternParentPath.insertAfter(\n                  objectPatterns.map(({ left, right }) =>\n                    t.assignmentExpression(\"=\", left, right),\n                  ),\n                );\n              }\n              break;\n            default:\n              throw new Error(\n                `Unexpected pattern parent type: ${patternParent.type}`,\n              );\n          }\n        }\n      },\n\n      // var a = { ...b, ...c }\n      ObjectExpression(path, file) {\n        if (!hasSpread(path.node)) return;\n\n        let helper: t.Identifier | t.MemberExpression;\n        if (setSpreadProperties) {\n          helper = getExtendsHelper(file);\n        } else {\n          if (process.env.BABEL_8_BREAKING) {\n            helper = file.addHelper(\"objectSpread2\");\n          } else {\n            try {\n              helper = file.addHelper(\"objectSpread2\");\n            } catch {\n              // TODO: This is needed to workaround https://github.com/babel/babel/issues/10187\n              // and https://github.com/babel/babel/issues/10179 for older @babel/core versions\n              // where #10187 isn't fixed.\n              this.file.declarations.objectSpread2 = null;\n\n              // objectSpread2 has been introduced in v7.5.0\n              // We have to maintain backward compatibility.\n              helper = file.addHelper(\"objectSpread\");\n            }\n          }\n        }\n\n        let exp: t.CallExpression = null;\n        let props: t.ObjectMember[] = [];\n\n        function make() {\n          const hadProps = props.length > 0;\n          const obj = t.objectExpression(props);\n          props = [];\n\n          if (!exp) {\n            exp = t.callExpression(helper, [obj]);\n            return;\n          }\n\n          // When we can assume that getters are pure and don't depend on\n          // the order of evaluation, we can avoid making multiple calls.\n          if (pureGetters) {\n            if (hadProps) {\n              exp.arguments.push(obj);\n            }\n            return;\n          }\n\n          exp = t.callExpression(t.cloneNode(helper), [\n            exp,\n            // If we have static props, we need to insert an empty object\n            // because the odd arguments are copied with [[Get]], not\n            // [[GetOwnProperty]]\n            ...(hadProps ? [t.objectExpression([]), obj] : []),\n          ]);\n        }\n\n        for (const prop of path.node.properties) {\n          if (t.isSpreadElement(prop)) {\n            make();\n            exp.arguments.push(prop.argument);\n          } else {\n            props.push(prop);\n          }\n        }\n\n        if (props.length) make();\n\n        path.replaceWith(exp);\n      },\n    },\n  };\n});\n"],"names":["shouldStoreRHSInTemporaryVariable","node","type","nonNullElements","elements","filter","element","length","properties","firstProperty","value","left","argument","chrome","opera","edge","firefox","safari","deno","ios","samsung","opera_mobile","electron","t","identifier","property","objectProperty","pattern","objectPattern","ZERO_REFS","isReferenced","declare","api","opts","_api$assumption","_api$assumption2","_api$assumption3","_api$assumption4","assertVersion","targets","supportsObjectAssign","isRequired","compatData","useBuiltIns","loose","Error","ignoreFunctionLength","assumption","objectRestNoSymbols","pureGetters","setSpreadProperties","getExtendsHelper","file","memberExpression","addHelper","iterateObjectRestElement","path","elementPath","get","isRestElement","propertyPath","hasObjectRestElement","objectRestPatternIterator","next","done","visitObjectRestElements","visitor","restElementPath","hasSpread","prop","isSpreadElement","extractNormalizedKeys","propsList","map","p","keys","allPrimitives","hasTemplateLiteral","key","isIdentifier","computed","push","stringLiteral","name","isTemplateLiteral","cloneNode","isLiteral","String","isAssignmentExpression","keyToCheck","right","isMemberExpression","object","isCallExpression","matchesPattern","callee","replaceImpureComputedKeys","scope","tempVariableDeclarations","keyExpression","identName","hasUid","isPure","tempVariableName","generateUidBasedOnNode","tempVariableDeclaration","variableDeclarator","replaceWith","removeUnusedExcludedKeys","bindings","getOuterBindingIdentifierPaths","Object","forEach","bindingName","bindingParentPath","parentPath","getBinding","references","isObjectProperty","remove","collectComputedKeysInSourceOrder","destructuringPattern","computedProperties","visitPattern","isObjectPattern","nestedPattern","isArrayPattern","restArgument","isAssignmentPattern","createObjectRest","objRef","props","last","assertRestElement","restElement","impureComputedPropertyDeclarators","callExpression","objectExpression","sequenceExpression","arrayExpression","isProgram","block","program","findParent","id","generateUidIdentifier","init","kind","replaceRestElement","paramPath","container","i","uid","declar","variableDeclaration","ensureBlock","unshiftContainer","manipulateOptions","_","parser","plugins","Function","params","paramsWithRestElement","Set","idsInRestParams","param","add","getBindingIdentifiers","idInRest","IdentifierHandler","functionScope","has","stop","isReferencedIdentifier","isBindingIdentifier","traverse","skip","shouldTransformParam","idx","convertFunctionParams","VariableDeclarator","insertionPath","originalPath","propertiesWithComputedKeys","computedKeyExpression","tempIdentifier","assignmentExpression","initRef","generateUidIdentifierBasedOnNode","insertBefore","ref","refPropertyPath","unshift","isVariableDeclarator","impureObjRefComputedDeclarators","keyPath","keyForMemberExpression","objectPatternPath","assertIdentifier","insertAfter","registerBinding","ExportNamedDeclaration","_path$splitExportDecl","declaration","isVariableDeclaration","hasRest","some","splitExportDeclaration","require","NodePath","prototype","CatchClause","AssignmentExpression","leftPath","nodes","refName","nodeWithoutSpread","expressionStatement","replaceWithMultiple","ForXStatement","temp","statementBody","body","isCompletionRecord","buildUndefinedNode","unshiftForXStatementBody","crawl","patternPath","ArrayPattern","objectPatterns","uidIdentifiers","patternParentPath","isPattern","patternParent","uidIdentifier","ObjectExpression","helper","_unused","declarations","objectSpread2","exp","make","hadProps","obj","arguments"],"mappings":"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"}
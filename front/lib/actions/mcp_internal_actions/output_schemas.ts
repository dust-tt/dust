import { INTERNAL_MIME_TYPES } from "@dust-tt/client";
import type {
  CallToolResult,
  Notification,
} from "@modelcontextprotocol/sdk/types.js";
import { NotificationSchema } from "@modelcontextprotocol/sdk/types.js";
import { z } from "zod";

import { MCP_TOOL_STAKE_LEVELS } from "@app/lib/actions/constants";
import type {
  CustomServerIconType,
  InternalAllowedIconType,
} from "@app/lib/actions/mcp_icons";
import {
  CUSTOM_SERVER_ALLOWED,
  INTERNAL_ALLOWED_ICONS,
} from "@app/lib/actions/mcp_icons";
import type { AllSupportedFileContentType } from "@app/types";
import { CONNECTOR_PROVIDERS } from "@app/types";
import { ALL_FILE_FORMATS } from "@app/types";

export function isBlobResource(
  outputBlock: CallToolResult["content"][number]
): outputBlock is {
  type: "resource";
  resource: {
    uri: string;
    blob: string;
    mimeType?: string;
  };
} {
  return outputBlock.type === "resource" && "blob" in outputBlock.resource;
}

// File generated by the tool during its execution.

const ToolGeneratedFileSchema = z.object({
  text: z.string(),
  uri: z.string(),
  mimeType: z.literal(INTERNAL_MIME_TYPES.TOOL_OUTPUT.FILE),
  fileId: z.string(),
  title: z.string(),
  contentType: z.enum(
    Object.keys(ALL_FILE_FORMATS) as [
      AllSupportedFileContentType,
      ...AllSupportedFileContentType[],
    ]
  ),
  snippet: z.string().nullable(),
});

export type ToolGeneratedFileType = z.infer<typeof ToolGeneratedFileSchema>;

export function isToolGeneratedFile(
  outputBlock: CallToolResult["content"][number]
): outputBlock is { type: "resource"; resource: ToolGeneratedFileType } {
  return (
    outputBlock.type === "resource" &&
    ToolGeneratedFileSchema.safeParse(outputBlock.resource).success
  );
}

// Thinking tokens generated during the tool execution.

const ThinkingOutputSchema = z.object({
  mimeType: z.literal(INTERNAL_MIME_TYPES.TOOL_OUTPUT.THINKING),
  text: z.string(),
  uri: z.literal(""),
});

export type ThinkingOutputType = z.infer<typeof ThinkingOutputSchema>;

export function isThinkingOutput(
  outputBlock: CallToolResult["content"][number]
): outputBlock is { type: "resource"; resource: ThinkingOutputType } {
  return (
    outputBlock.type === "resource" &&
    ThinkingOutputSchema.safeParse(outputBlock.resource).success
  );
}

// Final output of the reasoning when successful with the non-CoT tokens.

export const ReasoningSuccessOutputSchema = z.object({
  mimeType: z.literal(INTERNAL_MIME_TYPES.TOOL_OUTPUT.REASONING_SUCCESS),
  text: z.string(),
  uri: z.literal(""),
});

export type ReasoningSuccessOutputType = z.infer<
  typeof ReasoningSuccessOutputSchema
>;

export function isReasoningSuccessOutput(
  outputBlock: CallToolResult["content"][number]
): outputBlock is { type: "resource"; resource: ReasoningSuccessOutputType } {
  return (
    outputBlock.type === "resource" &&
    ReasoningSuccessOutputSchema.safeParse(outputBlock.resource).success
  );
}

// SQL query generated during the tool execution.

const SqlQueryOutputSchema = z.object({
  mimeType: z.literal(INTERNAL_MIME_TYPES.TOOL_OUTPUT.SQL_QUERY),
  text: z.string(),
  uri: z.literal(""),
});

export type SqlQueryOutputType = z.infer<typeof SqlQueryOutputSchema>;

export function isSqlQueryOutput(
  outputBlock: CallToolResult["content"][number]
): outputBlock is { type: "resource"; resource: SqlQueryOutputType } {
  return (
    outputBlock.type === "resource" &&
    SqlQueryOutputSchema.safeParse(outputBlock.resource).success
  );
}

// Resource with a name.

type ResourceWithName = {
  name: string;
};

export const isResourceWithName = (
  resource: object
): resource is ResourceWithName => {
  return "name" in resource && typeof resource.name === "string";
};

export const DatabaseSchemaResourceSchema = z.object({
  mimeType: z.literal(INTERNAL_MIME_TYPES.TOOL_OUTPUT.DATABASE_SCHEMA),
  text: z.string(),
  uri: z.string(),
});

export type DatabaseSchemaResourceType = z.infer<
  typeof DatabaseSchemaResourceSchema
>;

export const isDatabaseSchemaResourceType = (
  outputBlock: CallToolResult["content"][number]
): outputBlock is {
  type: "resource";
  resource: DatabaseSchemaResourceType;
} => {
  return (
    outputBlock.type === "resource" &&
    DatabaseSchemaResourceSchema.safeParse(outputBlock.resource).success
  );
};

export const QueryWritingInstructionsResourceSchema = z.object({
  mimeType: z.literal(
    INTERNAL_MIME_TYPES.TOOL_OUTPUT.QUERY_WRITING_INSTRUCTIONS
  ),
  text: z.string(),
  uri: z.string(),
});

export type QueryWritingInstructionsResourceType = z.infer<
  typeof QueryWritingInstructionsResourceSchema
>;

export const isQueryWritingInstructionsResourceType = (
  outputBlock: CallToolResult["content"][number]
): outputBlock is {
  type: "resource";
  resource: QueryWritingInstructionsResourceType;
} => {
  return (
    outputBlock.type === "resource" &&
    QueryWritingInstructionsResourceSchema.safeParse(outputBlock.resource)
      .success
  );
};

export const ExampleRowsResourceSchema = z.object({
  mimeType: z.literal(INTERNAL_MIME_TYPES.TOOL_OUTPUT.EXAMPLE_ROWS),
  text: z.string(),
  uri: z.string(),
});

export type ExampleRowsResourceType = z.infer<typeof ExampleRowsResourceSchema>;

export const isExampleRowsResourceType = (
  outputBlock: CallToolResult["content"][number]
): outputBlock is { type: "resource"; resource: ExampleRowsResourceType } => {
  return (
    outputBlock.type === "resource" &&
    ExampleRowsResourceSchema.safeParse(outputBlock.resource).success
  );
};

export const ToolMarkerResourceSchema = z.object({
  mimeType: z.literal(INTERNAL_MIME_TYPES.TOOL_OUTPUT.TOOL_MARKER),
  text: z.string(),
  uri: z.literal(""),
});

export type ToolMarkerResourceType = z.infer<typeof ToolMarkerResourceSchema>;

export function isToolMarkerResourceType(
  outputBlock: CallToolResult["content"][number]
): outputBlock is {
  type: "resource";
  resource: ToolMarkerResourceType;
} {
  return (
    outputBlock.type === "resource" &&
    ToolMarkerResourceSchema.safeParse(outputBlock.resource).success
  );
}

export const GET_DATABASE_SCHEMA_MARKER = "get_database_schema_marker" as const;

export function isGetDatabaseSchemaMarkerResourceType(
  outputBlock: CallToolResult["content"][number]
): outputBlock is {
  type: "resource";
  resource: ToolMarkerResourceType & {
    text: typeof GET_DATABASE_SCHEMA_MARKER;
  };
} {
  return (
    isToolMarkerResourceType(outputBlock) &&
    outputBlock.resource.text === GET_DATABASE_SCHEMA_MARKER
  );
}

export const EXECUTE_TABLES_QUERY_MARKER =
  "execute_tables_query_marker" as const;

export function isExecuteTablesQueryMarkerResourceType(
  outputBlock: CallToolResult["content"][number]
): outputBlock is {
  type: "resource";
  resource: ToolMarkerResourceType & {
    text: typeof EXECUTE_TABLES_QUERY_MARKER;
  };
} {
  return (
    isToolMarkerResourceType(outputBlock) &&
    outputBlock.resource.text === EXECUTE_TABLES_QUERY_MARKER
  );
}

export const ExecuteTablesQueryErrorResourceSchema = z.object({
  mimeType: z.literal(
    INTERNAL_MIME_TYPES.TOOL_OUTPUT.EXECUTE_TABLES_QUERY_ERROR
  ),
  text: z.string(),
  uri: z.literal(""),
});

export type ExecuteTablesQueryErrorResourceType = z.infer<
  typeof ExecuteTablesQueryErrorResourceSchema
>;

export const isExecuteTablesQueryErrorResourceType = (
  outputBlock: CallToolResult["content"][number]
): outputBlock is {
  type: "resource";
  resource: ExecuteTablesQueryErrorResourceType;
} => {
  return (
    outputBlock.type === "resource" &&
    ExecuteTablesQueryErrorResourceSchema.safeParse(outputBlock.resource)
      .success
  );
};

// Data source search outputs: query and results.

export const SearchQueryResourceSchema = z.object({
  mimeType: z.literal(INTERNAL_MIME_TYPES.TOOL_OUTPUT.DATA_SOURCE_SEARCH_QUERY),
  text: z.string(),
  uri: z.literal(""),
});

export type SearchQueryResourceType = z.infer<typeof SearchQueryResourceSchema>;

export const isSearchQueryResourceType = (
  outputBlock: CallToolResult["content"][number]
): outputBlock is { type: "resource"; resource: SearchQueryResourceType } => {
  return (
    outputBlock.type === "resource" &&
    SearchQueryResourceSchema.safeParse(outputBlock.resource).success
  );
};

export const SearchResultResourceSchema = z.object({
  mimeType: z.literal(
    INTERNAL_MIME_TYPES.TOOL_OUTPUT.DATA_SOURCE_SEARCH_RESULT
  ),
  uri: z.string(),
  text: z.string(),

  // Document metadata
  id: z.string(),
  tags: z.array(z.string()),
  ref: z.string(),
  chunks: z.array(z.string()),
  source: z.object({
    provider: z.string().optional(),
  }),
});

export type SearchResultResourceType = z.infer<
  typeof SearchResultResourceSchema
>;

export const isSearchResultResourceType = (
  outputBlock: CallToolResult["content"][number]
): outputBlock is { type: "resource"; resource: SearchResultResourceType } => {
  return (
    outputBlock.type === "resource" &&
    SearchResultResourceSchema.safeParse(outputBlock.resource).success
  );
};

// Data source inclusion outputs, query and results
export const IncludeQueryResourceSchema = z.object({
  mimeType: z.literal(
    INTERNAL_MIME_TYPES.TOOL_OUTPUT.DATA_SOURCE_INCLUDE_QUERY
  ),
  text: z.string(),
  uri: z.literal(""),
});

export type IncludeQueryResourceType = z.infer<
  typeof IncludeQueryResourceSchema
>;

export const isIncludeQueryResourceType = (
  outputBlock: CallToolResult["content"][number]
): outputBlock is { type: "resource"; resource: IncludeQueryResourceType } => {
  return (
    outputBlock.type === "resource" &&
    IncludeQueryResourceSchema.safeParse(outputBlock.resource).success
  );
};

export const WarningResourceSchema = z.object({
  mimeType: z.literal(INTERNAL_MIME_TYPES.TOOL_OUTPUT.WARNING),
  warningTitle: z.string(),
  text: z.string(),
  warningData: z.record(z.string(), z.unknown()).optional(),
  uri: z.literal(""),
});

export type WarningResourceType = z.infer<typeof WarningResourceSchema>;

export const isWarningResourceType = (
  outputBlock: CallToolResult["content"][number]
): outputBlock is {
  type: "resource";
  resource: WarningResourceType;
} => {
  return (
    outputBlock.type === "resource" &&
    WarningResourceSchema.safeParse(outputBlock.resource).success
  );
};

export const IncludeResultResourceSchema = z.object({
  mimeType: z.literal(
    INTERNAL_MIME_TYPES.TOOL_OUTPUT.DATA_SOURCE_INCLUDE_RESULT
  ),
  uri: z.string(),
  text: z.string(),

  // Document metadata
  id: z.string(),
  tags: z.array(z.string()),
  ref: z.string(),
  chunks: z.array(z.string()),
  source: z.object({
    name: z.string(),
    provider: z.string().optional(),
  }),
});

export type IncludeResultResourceType = z.infer<
  typeof IncludeResultResourceSchema
>;

export const isIncludeResultResourceType = (
  outputBlock: CallToolResult["content"][number]
): outputBlock is { type: "resource"; resource: IncludeResultResourceType } => {
  return (
    outputBlock.type === "resource" &&
    IncludeResultResourceSchema.safeParse(outputBlock.resource).success
  );
};

// Websearch results.

export const WebsearchQueryResourceSchema = z.object({
  mimeType: z.literal(INTERNAL_MIME_TYPES.TOOL_OUTPUT.WEBSEARCH_QUERY),
  text: z.string(),
  uri: z.literal(""),
});

export type WebsearchQueryResourceType = z.infer<
  typeof WebsearchQueryResourceSchema
>;

export const isWebsearchQueryResourceType = (
  outputBlock: CallToolResult["content"][number]
): outputBlock is {
  type: "resource";
  resource: WebsearchQueryResourceType;
} => {
  return (
    outputBlock.type === "resource" &&
    WebsearchQueryResourceSchema.safeParse(outputBlock.resource).success
  );
};

export const WebsearchResultResourceSchema = z.object({
  mimeType: z.literal(INTERNAL_MIME_TYPES.TOOL_OUTPUT.WEBSEARCH_RESULT),
  title: z.string(),
  text: z.string(),
  uri: z.string(),
  reference: z.string(),
});

export type WebsearchResultResourceType = z.infer<
  typeof WebsearchResultResourceSchema
>;

export const isWebsearchResultResourceType = (
  outputBlock: CallToolResult["content"][number]
): outputBlock is {
  type: "resource";
  resource: WebsearchResultResourceType;
} => {
  return (
    outputBlock.type === "resource" &&
    WebsearchResultResourceSchema.safeParse(outputBlock.resource).success
  );
};

// Browse results.

export const BrowseResultResourceSchema = z.object({
  mimeType: z.literal(INTERNAL_MIME_TYPES.TOOL_OUTPUT.BROWSE_RESULT),
  requestedUrl: z.string(),
  uri: z.string(), // Browsed url, might differ from the requested url
  text: z.string(),
  html: z.string().optional(),
  title: z.string().optional(),
  description: z.string().optional(),
  responseCode: z.string(),
  errorMessage: z.string().optional(),
});

export type BrowseResultResourceType = z.infer<
  typeof BrowseResultResourceSchema
>;

export const isBrowseResultResourceType = (
  outputBlock: CallToolResult["content"][number]
): outputBlock is {
  type: "resource";
  resource: BrowseResultResourceType;
} => {
  return (
    outputBlock.type === "resource" &&
    BrowseResultResourceSchema.safeParse(outputBlock.resource).success
  );
};

// RunAgent results.

export const RunAgentQueryResourceSchema = z.object({
  mimeType: z.literal(INTERNAL_MIME_TYPES.TOOL_OUTPUT.RUN_AGENT_QUERY),
  text: z.string(),
  childAgentId: z.string(),
  uri: z.literal(""),
});

export type RunAgentQueryResourceType = z.infer<
  typeof RunAgentQueryResourceSchema
>;

export const isRunAgentQueryResourceType = (
  outputBlock: CallToolResult["content"][number]
): outputBlock is {
  type: "resource";
  resource: RunAgentQueryResourceType;
} => {
  return (
    outputBlock.type === "resource" &&
    RunAgentQueryResourceSchema.safeParse(outputBlock.resource).success
  );
};

// Agent creation results.

export const AgentCreationResultResourceSchema = z.object({
  mimeType: z.literal(INTERNAL_MIME_TYPES.TOOL_OUTPUT.AGENT_CREATION_RESULT),
  text: z.string(), // Required by MCP SDK
  uri: z.string(),
  mainAgent: z.object({
    id: z.string(),
    name: z.string(),
    description: z.string(),
    pictureUrl: z.string(),
    url: z.string(),
  }),
  subAgent: z.optional(
    z.object({
      id: z.string(),
      name: z.string(),
      description: z.string(),
      pictureUrl: z.string(),
      url: z.string(),
    })
  ),
});

export type AgentCreationResultResourceType = z.infer<
  typeof AgentCreationResultResourceSchema
>;

export const isAgentCreationResultResourceType = (
  outputBlock: CallToolResult["content"][number]
): outputBlock is {
  type: "resource";
  resource: AgentCreationResultResourceType;
} => {
  return (
    outputBlock.type === "resource" &&
    AgentCreationResultResourceSchema.safeParse(outputBlock.resource).success
  );
};

export const RunAgentResultResourceSchema = z.object({
  mimeType: z.literal(INTERNAL_MIME_TYPES.TOOL_OUTPUT.RUN_AGENT_RESULT),
  conversationId: z.string(),
  text: z.string(),
  chainOfThought: z.string().optional(),
  uri: z.string(),
  refs: z
    .record(
      z.string(),
      z.object({
        description: z.string().optional(),
        href: z.string().optional(),
        title: z.string(),
        provider: z.string(),
      })
    )
    .optional(),
});

export type RunAgentResultResourceType = z.infer<
  typeof RunAgentResultResourceSchema
>;

export const isRunAgentResultResourceType = (
  outputBlock: CallToolResult["content"][number]
): outputBlock is {
  type: "resource";
  resource: RunAgentResultResourceType;
} => {
  return (
    outputBlock.type === "resource" &&
    RunAgentResultResourceSchema.safeParse(outputBlock.resource).success
  );
};

// Extract data outputs: query and results.

export const ExtractQueryResourceSchema = z.object({
  mimeType: z.literal(INTERNAL_MIME_TYPES.TOOL_OUTPUT.EXTRACT_QUERY),
  text: z.string(),
  uri: z.literal(""),
});

export type ExtractQueryResourceType = z.infer<
  typeof ExtractQueryResourceSchema
>;

export const isExtractQueryResourceType = (
  outputBlock: CallToolResult["content"][number]
): outputBlock is { type: "resource"; resource: ExtractQueryResourceType } => {
  return (
    outputBlock.type === "resource" &&
    ExtractQueryResourceSchema.safeParse(outputBlock.resource).success
  );
};

export const ExtractResultResourceSchema = z.object({
  mimeType: z.literal(INTERNAL_MIME_TYPES.TOOL_OUTPUT.EXTRACT_RESULT),
  uri: z.string(),
  text: z.string(),

  // File metadata
  fileId: z.string(),
  title: z.string(),
  contentType: z.string(),
  snippet: z.string().nullable(),
});

export type ExtractResultResourceType = z.infer<
  typeof ExtractResultResourceSchema
>;

export const isExtractResultResourceType = (
  outputBlock: CallToolResult["content"][number]
): outputBlock is { type: "resource"; resource: ExtractResultResourceType } => {
  return (
    outputBlock.type === "resource" &&
    ExtractResultResourceSchema.safeParse(outputBlock.resource).success
  );
};

// Schema for a content node rendered into a model-friendly format.
const RenderedNodeSchema = z.object({
  nodeId: z.string(),
  title: z.string(),
  path: z.string(),
  parentTitle: z.string().nullable(),
  lastUpdatedAt: z.string(),
  sourceUrl: z.string().nullable(),
  mimeType: z.string(),
  hasChildren: z.boolean(),
  connectorProvider: z.enum(CONNECTOR_PROVIDERS).nullable(),
});

export const DataSourceNodeListSchema = z.object({
  mimeType: z.literal(INTERNAL_MIME_TYPES.TOOL_OUTPUT.DATA_SOURCE_NODE_LIST),
  uri: z.literal(""),
  text: z.string(),

  data: z.array(RenderedNodeSchema),
  nextPageCursor: z.string().nullable(),
  resultCount: z.number(),
});

export type DataSourceNodeListType = z.infer<typeof DataSourceNodeListSchema>;

export const isDataSourceNodeListType = (
  outputBlock: CallToolResult["content"][number]
): outputBlock is { type: "resource"; resource: DataSourceNodeListType } => {
  return (
    outputBlock.type === "resource" &&
    DataSourceNodeListSchema.safeParse(outputBlock.resource).success
  );
};

const RenderedWarehouseNodeSchema = z.object({
  nodeId: z.string(),
  title: z.string(),
  path: z.string(),
  parentTitle: z.string().nullable(),
  mimeType: z.string(),
  hasChildren: z.boolean(),
  connectorProvider: z.enum(CONNECTOR_PROVIDERS).nullable(),
  sourceUrl: z.undefined(),
  lastUpdatedAt: z.undefined(),
});
export type RenderedWarehouseNodeType = z.infer<
  typeof RenderedWarehouseNodeSchema
>;

export const DataSourceNodeContentSchema = z.object({
  mimeType: z.literal(INTERNAL_MIME_TYPES.TOOL_OUTPUT.DATA_SOURCE_NODE_CONTENT),
  uri: z.string(),
  text: z.string(),
  metadata: RenderedNodeSchema,
});

export type DataSourceNodeContentType = z.infer<
  typeof DataSourceNodeContentSchema
>;

export const isDataSourceNodeContentType = (
  outputBlock: CallToolResult["content"][number]
): outputBlock is {
  type: "resource";
  resource: DataSourceNodeContentType;
} => {
  return (
    outputBlock.type === "resource" &&
    DataSourceNodeContentSchema.safeParse(outputBlock.resource).success
  );
};

// Schema for a locate_in_tree path item.
const FilesystemPathItemSchema = z.object({
  nodeId: z.string(),
  title: z.string(),
  nodeType: z.enum(["document", "table", "folder"]),
  sourceUrl: z.string().nullable(),
  isCurrentNode: z.boolean(),
});

export const FilesystemPathSchema = z.object({
  mimeType: z.literal(INTERNAL_MIME_TYPES.TOOL_OUTPUT.FILESYSTEM_PATH),
  uri: z.literal(""),
  text: z.string(),
  path: z.array(FilesystemPathItemSchema),
});

export type FilesystemPathType = z.infer<typeof FilesystemPathSchema>;

export const isFilesystemPathType = (
  outputBlock: CallToolResult["content"][number]
): outputBlock is {
  type: "resource";
  resource: FilesystemPathType;
} => {
  return (
    outputBlock.type === "resource" &&
    FilesystemPathSchema.safeParse(outputBlock.resource).success
  );
};

/**
 * Notification output types.
 */

// Image.

const NotificationImageContentSchema = z.object({
  type: z.literal("image"),
  mimeType: z.string(),
});

type ImageProgressOutput = z.infer<typeof NotificationImageContentSchema>;

export function isImageProgressOutput(
  output: ProgressNotificationOutput
): output is ImageProgressOutput {
  return output !== undefined && output.type === "image";
}

// Interactive file.

const NotificationInteractiveFileContentSchema = z.object({
  type: z.literal("interactive_file"),
  fileId: z.string(),
  mimeType: z.string(),
  title: z.string(),
  updatedAt: z.string(),
});

type InteractiveFileContentProgressOutput = z.infer<
  typeof NotificationInteractiveFileContentSchema
>;

export function isInteractiveFileContentOutput(
  output: ProgressNotificationOutput
): output is InteractiveFileContentProgressOutput {
  return output !== undefined && output.type === "interactive_file";
}

const InternalAllowedIconSchema = z.enum(
  INTERNAL_ALLOWED_ICONS as [
    InternalAllowedIconType,
    ...InternalAllowedIconType[],
  ]
);

const CustomServerIconSchema = z.enum(
  CUSTOM_SERVER_ALLOWED as [CustomServerIconType, ...CustomServerIconType[]]
);

// Schema for the resource of a notification where the tool is asking for tool approval.
// This schema contains all the information that the MCP server runner
// needs to emit an event for tool approval.
const NotificationToolApproveBubbleUpContentSchema = z.object({
  type: z.literal("tool_approval_bubble_up"),
  configurationId: z.string(),
  conversationId: z.string(),
  messageId: z.string(),
  actionId: z.string(),
  inputs: z.record(z.unknown()),
  stake: z.enum(MCP_TOOL_STAKE_LEVELS).optional(),
  metadata: z.object({
    mcpServerName: z.string(),
    toolName: z.string(),
    agentName: z.string(),
    icon: z
      .union([InternalAllowedIconSchema, CustomServerIconSchema])
      .optional(),
  }),
});

type NotificationToolApproveBubbleUpContentType = z.infer<
  typeof NotificationToolApproveBubbleUpContentSchema
>;

export function isToolApproveBubbleUpNotificationType(
  notificationOutput: ProgressNotificationOutput
): notificationOutput is NotificationToolApproveBubbleUpContentType {
  return NotificationToolApproveBubbleUpContentSchema.safeParse(
    notificationOutput
  ).success;
}

const NotificationTextContentSchema = z.object({
  type: z.literal("text"),
  text: z.string(),
});

const NotificationRunAgentContentSchema = z.object({
  type: z.literal("run_agent"),
  childAgentId: z.string(),
  conversationId: z.string(),
  query: z.string(),
});

type RunAgentQueryProgressOutput = z.infer<
  typeof NotificationRunAgentContentSchema
>;

export function isRunAgentQueryProgressOutput(
  output: ProgressNotificationOutput
): output is RunAgentQueryProgressOutput {
  return (
    output !== undefined &&
    output.type === "run_agent" &&
    "childAgentId" in output
  );
}

const NotificationRunAgentChainOfThoughtSchema = z.object({
  type: z.literal("run_agent_chain_of_thought"),
  childAgentId: z.string(),
  conversationId: z.string(),
  chainOfThought: z.string(),
});

const NotificationRunAgentGenerationTokensSchema = z.object({
  type: z.literal("run_agent_generation_tokens"),
  childAgentId: z.string(),
  conversationId: z.string(),
  text: z.string(),
});

type RunAgentChainOfThoughtProgressOutput = z.infer<
  typeof NotificationRunAgentChainOfThoughtSchema
>;

export function isRunAgentChainOfThoughtProgressOutput(
  output: ProgressNotificationOutput
): output is RunAgentChainOfThoughtProgressOutput {
  return (
    output !== undefined &&
    output.type === "run_agent_chain_of_thought" &&
    "chainOfThought" in output
  );
}

type RunAgentGenerationTokensProgressOutput = z.infer<
  typeof NotificationRunAgentGenerationTokensSchema
>;

export function isRunAgentGenerationTokensProgressOutput(
  output: ProgressNotificationOutput
): output is RunAgentGenerationTokensProgressOutput {
  return (
    output !== undefined &&
    output.type === "run_agent_generation_tokens" &&
    "text" in output &&
    !("chainOfThought" in output)
  );
}

export function isRunAgentProgressOutput(
  output: ProgressNotificationOutput
): output is
  | RunAgentQueryProgressOutput
  | RunAgentChainOfThoughtProgressOutput
  | RunAgentGenerationTokensProgressOutput {
  return (
    isRunAgentQueryProgressOutput(output) ||
    isRunAgentChainOfThoughtProgressOutput(output) ||
    isRunAgentGenerationTokensProgressOutput(output)
  );
}

export const ProgressNotificationOutputSchema = z
  .union([
    NotificationImageContentSchema,
    NotificationInteractiveFileContentSchema,
    NotificationRunAgentContentSchema,
    NotificationRunAgentChainOfThoughtSchema,
    NotificationRunAgentGenerationTokensSchema,
    NotificationTextContentSchema,
    NotificationToolApproveBubbleUpContentSchema,
  ])
  .optional();

type ProgressNotificationOutput = z.infer<
  typeof ProgressNotificationOutputSchema
>;

export const ProgressNotificationContentSchema = z.object({
  // Required for the MCP protocol.
  progress: z.number(),
  total: z.number(),
  progressToken: z.union([z.string(), z.number()]),
  // Custom data.
  data: z.object({
    label: z.string(),
    output: ProgressNotificationOutputSchema,
  }),
});

export type ProgressNotificationContentType = z.infer<
  typeof ProgressNotificationContentSchema
>;

export const MCPProgressNotificationSchema = NotificationSchema.extend({
  method: z.literal("notifications/progress"),
  params: ProgressNotificationContentSchema,
});

export type MCPProgressNotificationType = z.infer<
  typeof MCPProgressNotificationSchema
>;

export function isMCPProgressNotificationType(
  notification: Notification
): notification is MCPProgressNotificationType {
  return MCPProgressNotificationSchema.safeParse(notification).success;
}

export function isTextContent(
  content: CallToolResult["content"][number]
): content is { type: "text"; text: string } {
  return content.type === "text";
}

export function isResourceContentWithText(
  content: CallToolResult["content"][number]
): content is {
  type: "resource";
  resource: {
    [x: string]: unknown;
    text: string;
    uri: string;
    mimeType?: string | undefined;
  };
} {
  return (
    content.type === "resource" &&
    typeof content.resource === "object" &&
    content.resource !== null &&
    "text" in content.resource &&
    typeof (content.resource as any).text === "string"
  );
}

export const getOutputText = (
  output: CallToolResult["content"][number]
): string => {
  if (isTextContent(output)) {
    return output.text;
  }
  if (isResourceContentWithText(output)) {
    return output.resource.text;
  }
  return "";
};

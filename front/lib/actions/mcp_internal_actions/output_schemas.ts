import { INTERNAL_MIME_TYPES } from "@dust-tt/client";
import { z } from "zod";

import type { SupportedFileContentType } from "@app/types";
import { FILE_FORMATS } from "@app/types";

// Redeclared here to avoid an issue with the zod types in the @modelcontextprotocol/sdk
// See https://github.com/colinhacks/zod/issues/2938
const ResourceContentsSchema = z.object({
  uri: z.string(),
  mimeType: z.optional(z.string()),
});

const TextResourceContentsSchema = ResourceContentsSchema.extend({
  text: z.string(),
});

const BlobResourceContentsSchema = ResourceContentsSchema.extend({
  blob: z.string().base64(),
});

const TextContentSchema = z.object({
  type: z.literal("text"),
  text: z.string(),
});

const ImageContentSchema = z.object({
  type: z.literal("image"),
  data: z.string().base64(),
  mimeType: z.string(),
});

// File generated by the tool during its execution.

const ToolGeneratedFileSchema = z.object({
  text: z.string(),
  uri: z.string(),
  mimeType: z.literal(INTERNAL_MIME_TYPES.TOOL_OUTPUT.FILE),
  fileId: z.string(),
  title: z.string(),
  contentType: z.enum(
    Object.keys(FILE_FORMATS) as [
      SupportedFileContentType,
      ...SupportedFileContentType[],
    ]
  ),
  snippet: z.string().nullable(),
});

export type ToolGeneratedFile = z.infer<typeof ToolGeneratedFileSchema>;

export function isToolGeneratedFile(
  resource: EmbeddedResourceType
): resource is ToolGeneratedFile {
  return resource.mimeType === INTERNAL_MIME_TYPES.TOOL_OUTPUT.FILE;
}

// Thinking tokens generated during the tool execution.

const ThinkingOutputSchema = z.object({
  mimeType: z.literal(INTERNAL_MIME_TYPES.TOOL_OUTPUT.THINKING),
  text: z.string(),
  uri: z.literal(""),
});

export type ThinkingOutput = z.infer<typeof ThinkingOutputSchema>;

export function isThinkingOutput(
  resource: EmbeddedResourceType
): resource is ThinkingOutput {
  return resource.mimeType === INTERNAL_MIME_TYPES.TOOL_OUTPUT.THINKING;
}

// SQL query generated during the tool execution.

const SqlQueryOutputSchema = z.object({
  mimeType: z.literal(INTERNAL_MIME_TYPES.TOOL_OUTPUT.SQL_QUERY),
  text: z.string(),
  uri: z.literal(""),
});

export type SqlQueryOutput = z.infer<typeof SqlQueryOutputSchema>;

export function isSqlQueryOutput(
  resource: EmbeddedResourceType
): resource is SqlQueryOutput {
  return resource.mimeType === INTERNAL_MIME_TYPES.TOOL_OUTPUT.SQL_QUERY;
}
// Resource with a name.

type ResourceWithName = {
  name: string;
};

export const isResourceWithName = (
  resource: object
): resource is ResourceWithName => {
  return "name" in resource && typeof resource.name === "string";
};

// Data source search outputs: query and results.

export const SearchQueryResourceSchema = z.object({
  mimeType: z.literal(INTERNAL_MIME_TYPES.TOOL_OUTPUT.DATA_SOURCE_SEARCH_QUERY),
  text: z.string(),
  uri: z.literal(""),
});

export type SearchQueryResourceType = z.infer<typeof SearchQueryResourceSchema>;

export const SearchResultResourceSchema = z.object({
  mimeType: z.literal(
    INTERNAL_MIME_TYPES.TOOL_OUTPUT.DATA_SOURCE_SEARCH_RESULT
  ),
  uri: z.string(),
  text: z.string(),

  // Document metadata
  id: z.string(),
  tags: z.array(z.string()),
  ref: z.string(),
  chunks: z.array(z.string()),
  source: z.object({
    name: z.string(),
    provider: z.string().optional(),
  }),
});

export type SearchResultResourceType = z.infer<
  typeof SearchResultResourceSchema
>;

export const isSearchResultResourceType = (
  resource: object
): resource is SearchResultResourceType => {
  return (
    "mimeType" in resource &&
    resource.mimeType ===
      INTERNAL_MIME_TYPES.TOOL_OUTPUT.DATA_SOURCE_SEARCH_RESULT &&
    SearchResultResourceSchema.safeParse(resource).success
  );
};

// Generic output types and schemas.

const EmbeddedResourceSchema = z.union([
  BlobResourceContentsSchema,
  SearchQueryResourceSchema,
  SearchResultResourceSchema,
  TextResourceContentsSchema,
  ThinkingOutputSchema,
  ToolGeneratedFileSchema,
]);

type EmbeddedResourceType = z.infer<typeof EmbeddedResourceSchema>;

const MCPToolResultContentSchema = z.union([
  TextContentSchema,
  ImageContentSchema,
  z.object({
    type: z.literal("resource"),
    resource: EmbeddedResourceSchema,
  }),
]);

export type MCPToolResultContent = z.infer<typeof MCPToolResultContentSchema>;

export type MCPToolResult = {
  isError: boolean;
  content: MCPToolResultContent[];
};

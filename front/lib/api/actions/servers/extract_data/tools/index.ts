import assert from "assert";
import type { JSONSchema7 as JSONSchema } from "json-schema";

import { uploadFileToConversationDataSource } from "@app/lib/actions/action_file_helpers";
import { PROCESS_ACTION_TOP_K } from "@app/lib/actions/constants";
import { MCPError } from "@app/lib/actions/mcp_errors";
import type { DataSourcesToolConfigurationType } from "@app/lib/actions/mcp_internal_actions/input_schemas";
import type { ToolHandlers } from "@app/lib/actions/mcp_internal_actions/tool_definition";
import { buildTools } from "@app/lib/actions/mcp_internal_actions/tool_definition";
import { shouldAutoGenerateTags } from "@app/lib/actions/mcp_internal_actions/tools/tags/utils";
import type { AgentLoopContextType } from "@app/lib/actions/types";
import type { ProcessActionOutputsType } from "@app/lib/api/actions/servers/extract_data/helpers";
import {
  generateProcessToolOutput,
  getCoreDataSourceSearchCriterias,
  getPromptForProcessDustApp,
} from "@app/lib/api/actions/servers/extract_data/helpers";
import {
  EXTRACT_DATA_BASE_TOOLS_METADATA,
  EXTRACT_DATA_WITH_TAGS_TOOLS_METADATA,
} from "@app/lib/api/actions/servers/extract_data/metadata";
import { executeFindTags } from "@app/lib/api/actions/tools/find_tags";
import { processDataSources } from "@app/lib/api/assistant/process_data_sources";
import type { Authenticator } from "@app/lib/auth";
import { Err, Ok } from "@app/types/shared/result";
import type { TimeFrame } from "@app/types/shared/utils/time_frame";

// Create tools with access to auth via closure
export function createExtractDataTools(
  auth: Authenticator,
  agentLoopContext?: AgentLoopContextType
) {
  const areTagsDynamic = agentLoopContext
    ? shouldAutoGenerateTags(agentLoopContext)
    : false;

  async function extractFunction({
    dataSources,
    objective,
    jsonSchema,
    timeFrame,
    tagsIn,
    tagsNot,
  }: {
    dataSources: DataSourcesToolConfigurationType;
    objective: string;
    jsonSchema: JSONSchema;
    timeFrame?: TimeFrame;
    tagsIn?: string[];
    tagsNot?: string[];
  }) {
    // Unwrap and prepare variables.
    assert(
      agentLoopContext?.runContext,
      "agentLoopContext is required to run the extract_data tool"
    );
    const { agentConfiguration, conversation } = agentLoopContext.runContext;
    const { model } = agentConfiguration;

    // Defensive handling: parse jsonSchema if it arrives as a JSON string.
    // This can happen when the LLM generates a stringified JSON schema instead of an object,
    // or when the schema is stored as a string in the database.
    if (typeof jsonSchema === "string") {
      try {
        jsonSchema = JSON.parse(jsonSchema);
      } catch {
        return new Err(
          new MCPError(
            `Invalid jsonSchema: expected a valid JSON object but received a malformed string`
          )
        );
      }
    }

    // If jsonSchema was pre-configured by the user, i.e. not generated by the
    // tool, then it has an additional mimeType property, as is convention.
    // We remove it here before passing the jsonSchema to the LLM.
    // Thus the any cast.
    if ("mimeType" in jsonSchema) {
      delete (jsonSchema as any).mimeType;
    }

    // Similarly, if timeFrame was pre-configured by the user, it has an additional mimeType property.
    // We remove it here before passing the timeFrame to the LLM.
    if (timeFrame && "mimeType" in timeFrame) {
      delete (timeFrame as any).mimeType;
    }

    const prompt = await getPromptForProcessDustApp({
      auth,
      agentConfiguration,
      conversation,
    });

    const coreDataSourceSearchCriteriasResult =
      await getCoreDataSourceSearchCriterias(auth, dataSources, {
        timeFrame,
        tagsIn,
        tagsNot,
      });
    if (coreDataSourceSearchCriteriasResult.isErr()) {
      return new Err(
        new MCPError(
          `Error getting search criteria in extract data action: ${coreDataSourceSearchCriteriasResult.error.message}`
        )
      );
    }

    const res = await processDataSources({
      auth,
      coreDataSourceSearchCriterias: coreDataSourceSearchCriteriasResult.value,
      model,
      prompt,
      objective,
      jsonSchema,
      topK: PROCESS_ACTION_TOP_K,
    });

    if (res.isErr()) {
      return new Err(
        new MCPError(`Error running extract data action: ${res.error.message}`)
      );
    }

    const outputs: ProcessActionOutputsType = {
      data: res.value.data,
      total_documents: res.value.totalDocuments,
    };

    // Generate file and process tool output
    const { jsonFile, processToolOutput } = await generateProcessToolOutput({
      auth,
      conversation,
      outputs,
      jsonSchema,
      timeFrame: timeFrame ?? null,
      objective,
    });

    // Upload the file to the conversation data source.
    // This step is critical for file persistence across sessions.
    await uploadFileToConversationDataSource({
      auth,
      file: jsonFile,
    });

    return new Ok(processToolOutput);
  }

  if (!areTagsDynamic) {
    // Return base tools without tags
    const handlers: ToolHandlers<typeof EXTRACT_DATA_BASE_TOOLS_METADATA> = {
      extract_information_from_documents: async (params, _extra) => {
        return extractFunction(params);
      },
    };
    return buildTools(EXTRACT_DATA_BASE_TOOLS_METADATA, handlers);
  }

  // Return tools with tags support
  const handlers: ToolHandlers<typeof EXTRACT_DATA_WITH_TAGS_TOOLS_METADATA> = {
    extract_information_from_documents: async (params, _extra) => {
      return extractFunction(params);
    },
    find_tags: async ({ query, dataSources }, _extra) => {
      return executeFindTags(query, dataSources, auth);
    },
  };
  return buildTools(EXTRACT_DATA_WITH_TAGS_TOOLS_METADATA, handlers);
}

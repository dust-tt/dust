/**
 * Build-time script to fetch custom model configurations from GCS.
 * Run with: npx tsx scripts/fetch-custom-models.ts
 *
 * In production builds, this fetches configs from GCS and generates TypeScript.
 * In development (or when GCS is unavailable), the committed empty file is used.
 */

import * as fs from "fs";
import * as path from "path";

import { getPrivateUploadBucket } from "@app/lib/file_storage";

const CUSTOM_MODELS_GCS_PATH = "model-configs/custom.json";
const OUTPUT_PATH = path.join(
  __dirname,
  "../types/assistant/models/custom_models.generated.ts"
);

interface CustomModelConfig {
  modelId: string;
  providerId: string;
  displayName: string;
  contextSize: number;
  recommendedTopK: number;
  recommendedExhaustiveTopK: number;
  largeModel: boolean;
  description: string;
  shortDescription: string;
  isLegacy: boolean;
  isLatest: boolean;
  generationTokensCount: number;
  supportsVision: boolean;
  minimumReasoningEffort: string;
  maximumReasoningEffort: string;
  defaultReasoningEffort: string;
  tokenizer: { type: string; base?: string };
  nativeReasoningMetaPrompt?: string;
  formattingMetaPrompt?: string;
  toolUseMetaPrompt?: string;
  tokenCountAdjustment?: number;
  useNativeLightReasoning?: boolean;
  supportsResponseFormat?: boolean;
  supportsPromptCaching?: boolean;
  featureFlag?: string;
  customAssistantFeatureFlag?: string;
  customThinkingType?: string;
  customBetas?: string[];
  customOutputConfig?: Record<string, string>;
  disablePrefill?: boolean;
}

interface CustomModelsFile {
  version?: number;
  models: CustomModelConfig[];
}

async function fetchCustomModels(): Promise<CustomModelConfig[] | null> {
  try {
    const bucket = getPrivateUploadBucket();
    const content = await bucket.fetchFileContent(CUSTOM_MODELS_GCS_PATH);
    const parsed: CustomModelsFile = JSON.parse(content);

    if (!parsed.models || !Array.isArray(parsed.models)) {
      console.warn("Invalid custom models file format");
      return null;
    }

    console.log(`Found ${parsed.models.length} custom model(s)`);
    return parsed.models;
  } catch (err) {
    console.warn("Failed to fetch custom models from GCS:", err);
    return null;
  }
}

function generateTypeScript(models: CustomModelConfig[]): string {
  const modelConstants = models
    .map((model, idx) => {
      const configJson = JSON.stringify(model, null, 2)
        .split("\n")
        .map((line, i) => (i === 0 ? line : "  " + line))
        .join("\n");

      return `const CUSTOM_MODEL_${idx}_ID = "${model.modelId}" as const;
const CUSTOM_MODEL_${idx}_CONFIG = ${configJson} as const;`;
    })
    .join("\n\n");

  const configsArray = models
    .map((_, idx) => `  CUSTOM_MODEL_${idx}_CONFIG`)
    .join(",\n");
  const idsArray = models
    .map((_, idx) => `  CUSTOM_MODEL_${idx}_ID`)
    .join(",\n");

  return `// AUTO-GENERATED FILE - DO NOT EDIT MANUALLY
// Generated by scripts/fetch-custom-models.ts at build time from GCS.
import type { ModelConfigurationType } from "@app/types/assistant/models/types";

${modelConstants}

// Cast needed because ModelConfigurationType.modelId is the union type
export const CUSTOM_MODEL_CONFIGS = [
${configsArray},
] as unknown as ModelConfigurationType[];

export const CUSTOM_MODEL_IDS = [
${idsArray},
] as const;
`;
}

async function main() {
  console.log("Fetching custom models from GCS...");
  const models = await fetchCustomModels();

  if (models === null || models.length === 0) {
    console.log("No custom models found, using committed empty file");
    return;
  }

  console.log("Generating TypeScript file...");
  const content = generateTypeScript(models);

  fs.writeFileSync(OUTPUT_PATH, content);
  console.log(`Generated ${models.length} custom model(s)`);
}

main().catch((err) => {
  console.error("Failed to generate custom models:", err);
  process.exit(1);
});

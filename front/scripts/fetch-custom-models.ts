/**
 * Build-time script to fetch custom model configurations.
 * Run with: npx tsx scripts/fetch-custom-models.ts
 *
 * Priority:
 * 1. Local JSON file (downloaded by CI before Docker build)
 * 2. GCS bucket (for local dev with credentials)
 * 3. Committed empty file (fallback)
 */

import { ModelConfigurationSchema } from "@app/types/assistant/models/types";
import * as fs from "fs";
import * as path from "path";
import { z } from "zod";

// Local file path (downloaded by GH action before Docker build).
const LOCAL_JSON_PATH = path.join(__dirname, "../custom-models.json");
const OUTPUT_PATH = path.join(
  __dirname,
  "../types/assistant/models/custom_models.generated.ts"
);

const CustomModelsFileSchema = z.object({
  version: z.number().optional(),
  models: z.array(ModelConfigurationSchema),
});

type CustomModelConfig = z.infer<typeof ModelConfigurationSchema>;

function parseModelsFile(content: string): CustomModelConfig[] | null {
  try {
    const json = JSON.parse(content);
    const result = CustomModelsFileSchema.safeParse(json);

    if (!result.success) {
      console.error("Validation failed:", result.error.format());
      return null;
    }

    return result.data.models;
  } catch (err) {
    console.warn("Failed to parse custom models JSON:", err);
    return null;
  }
}

function readLocalFile(): CustomModelConfig[] | null {
  if (!fs.existsSync(LOCAL_JSON_PATH)) {
    return null;
  }
  console.log("Reading from local JSON file...");
  const content = fs.readFileSync(LOCAL_JSON_PATH, "utf-8");
  return parseModelsFile(content);
}

async function fetchFromGCS(): Promise<CustomModelConfig[] | null> {
  try {
    // Dynamic import to avoid errors when GCS deps aren't available.
    const { getPrivateUploadBucket } = await import("@app/lib/file_storage");
    const bucket = getPrivateUploadBucket();
    const content = await bucket.fetchFileContent("model-configs/custom.json");
    return parseModelsFile(content);
  } catch (err) {
    console.warn("Failed to fetch from GCS:", err);
    return null;
  }
}

function generateTypeScript(models: CustomModelConfig[]): string {
  const modelConstants = models
    .map((model, idx) => {
      const configJson = JSON.stringify(model, null, 2)
        .split("\n")
        .map((line, i) => (i === 0 ? line : "  " + line))
        .join("\n");

      return `const CUSTOM_MODEL_${idx}_ID = "${model.modelId}" as const;
const CUSTOM_MODEL_${idx}_CONFIG = ${configJson} as const;`;
    })
    .join("\n\n");

  const configsArray = models
    .map((_, idx) => `  CUSTOM_MODEL_${idx}_CONFIG`)
    .join(",\n");
  const idsArray = models
    .map((_, idx) => `  CUSTOM_MODEL_${idx}_ID`)
    .join(",\n");

  return `// AUTO-GENERATED FILE - DO NOT EDIT MANUALLY
// Generated by scripts/fetch-custom-models.ts at build time.
import type { ModelConfigurationType } from "@app/types/assistant/models/types";

${modelConstants}

// Cast needed because ModelConfigurationType.modelId is the union type
export const CUSTOM_MODEL_CONFIGS = [
${configsArray},
] as unknown as ModelConfigurationType[];

export const CUSTOM_MODEL_IDS = [
${idsArray},
] as const;
`;
}

async function main() {
  // Try local file first (CI environment).
  let models = readLocalFile();

  // Try GCS if no local file (local dev with credentials).
  if (models === null) {
    console.log("No local file, trying GCS...");
    models = await fetchFromGCS();
  }

  if (models === null || models.length === 0) {
    console.log("No custom models found, using committed empty file");
    return;
  }

  console.log(`Generating TypeScript for ${models.length} custom model(s)...`);
  const content = generateTypeScript(models);

  fs.writeFileSync(OUTPUT_PATH, content);
  console.log("Done");
}

main().catch((err) => {
  console.error("Failed to generate custom models:", err);
  process.exit(1);
});

{
  "version": 3,
  "sources": ["../../../../node_modules/micromark-extension-directive/dev/lib/factory-attributes.js", "../../../../node_modules/micromark-extension-directive/dev/lib/factory-label.js", "../../../../node_modules/micromark-extension-directive/dev/lib/factory-name.js", "../../../../node_modules/micromark-extension-directive/dev/lib/directive-container.js", "../../../../node_modules/micromark-extension-directive/dev/lib/directive-leaf.js", "../../../../node_modules/micromark-extension-directive/dev/lib/directive-text.js", "../../../../node_modules/micromark-extension-directive/dev/lib/syntax.js", "../../../../node_modules/character-entities-legacy/index.js", "../../../../node_modules/character-reference-invalid/index.js", "../../../../node_modules/is-decimal/index.js", "../../../../node_modules/is-hexadecimal/index.js", "../../../../node_modules/is-alphabetical/index.js", "../../../../node_modules/is-alphanumerical/index.js", "../../../../node_modules/parse-entities/lib/index.js", "../../../../node_modules/micromark-extension-directive/dev/lib/html.js", "../../../../node_modules/stringify-entities/lib/core.js", "../../../../node_modules/character-entities-html4/index.js", "../../../../node_modules/stringify-entities/lib/util/to-named.js", "../../../../node_modules/stringify-entities/lib/util/format-basic.js", "../../../../node_modules/stringify-entities/lib/index.js", "../../../../node_modules/mdast-util-directive/node_modules/unist-util-is/lib/index.js", "../../../../node_modules/mdast-util-directive/node_modules/unist-util-visit-parents/lib/color.browser.js", "../../../../node_modules/mdast-util-directive/node_modules/unist-util-visit-parents/lib/index.js", "../../../../node_modules/mdast-util-to-markdown/lib/util/check-quote.js", "../../../../node_modules/mdast-util-directive/lib/index.js", "../../../../node_modules/remark-directive/index.js"],
  "sourcesContent": ["/**\n * @typedef {import('micromark-util-types').Code} Code\n * @typedef {import('micromark-util-types').Effects} Effects\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenType} TokenType\n */\n\nimport {ok as assert} from 'uvu/assert'\nimport {factorySpace} from 'micromark-factory-space'\nimport {factoryWhitespace} from 'micromark-factory-whitespace'\nimport {\n  asciiAlpha,\n  asciiAlphanumeric,\n  markdownLineEnding,\n  markdownLineEndingOrSpace,\n  markdownSpace\n} from 'micromark-util-character'\nimport {codes} from 'micromark-util-symbol/codes.js'\nimport {types} from 'micromark-util-symbol/types.js'\n\n/**\n * @param {Effects} effects\n * @param {State} ok\n * @param {State} nok\n * @param {TokenType} attributesType\n * @param {TokenType} attributesMarkerType\n * @param {TokenType} attributeType\n * @param {TokenType} attributeIdType\n * @param {TokenType} attributeClassType\n * @param {TokenType} attributeNameType\n * @param {TokenType} attributeInitializerType\n * @param {TokenType} attributeValueLiteralType\n * @param {TokenType} attributeValueType\n * @param {TokenType} attributeValueMarker\n * @param {TokenType} attributeValueData\n * @param {boolean} [disallowEol=false]\n */\n/* eslint-disable-next-line max-params */\nexport function factoryAttributes(\n  effects,\n  ok,\n  nok,\n  attributesType,\n  attributesMarkerType,\n  attributeType,\n  attributeIdType,\n  attributeClassType,\n  attributeNameType,\n  attributeInitializerType,\n  attributeValueLiteralType,\n  attributeValueType,\n  attributeValueMarker,\n  attributeValueData,\n  disallowEol\n) {\n  /** @type {TokenType} */\n  let type\n  /** @type {Code | undefined} */\n  let marker\n\n  return start\n\n  /** @type {State} */\n  function start(code) {\n    assert(code === codes.leftCurlyBrace, 'expected `{`')\n    effects.enter(attributesType)\n    effects.enter(attributesMarkerType)\n    effects.consume(code)\n    effects.exit(attributesMarkerType)\n    return between\n  }\n\n  /** @type {State} */\n  function between(code) {\n    if (code === codes.numberSign) {\n      type = attributeIdType\n      return shortcutStart(code)\n    }\n\n    if (code === codes.dot) {\n      type = attributeClassType\n      return shortcutStart(code)\n    }\n\n    if (code === codes.colon || code === codes.underscore || asciiAlpha(code)) {\n      effects.enter(attributeType)\n      effects.enter(attributeNameType)\n      effects.consume(code)\n      return name\n    }\n\n    if (disallowEol && markdownSpace(code)) {\n      return factorySpace(effects, between, types.whitespace)(code)\n    }\n\n    if (!disallowEol && markdownLineEndingOrSpace(code)) {\n      return factoryWhitespace(effects, between)(code)\n    }\n\n    return end(code)\n  }\n\n  /** @type {State} */\n  function shortcutStart(code) {\n    // Assume itâ€™s registered.\n    const markerType = /** @type {TokenType} */ (type + 'Marker')\n    effects.enter(attributeType)\n    effects.enter(type)\n    effects.enter(markerType)\n    effects.consume(code)\n    effects.exit(markerType)\n    return shortcutStartAfter\n  }\n\n  /** @type {State} */\n  function shortcutStartAfter(code) {\n    if (\n      code === codes.eof ||\n      code === codes.quotationMark ||\n      code === codes.numberSign ||\n      code === codes.apostrophe ||\n      code === codes.dot ||\n      code === codes.lessThan ||\n      code === codes.equalsTo ||\n      code === codes.greaterThan ||\n      code === codes.graveAccent ||\n      code === codes.rightCurlyBrace ||\n      markdownLineEndingOrSpace(code)\n    ) {\n      return nok(code)\n    }\n\n    // Assume itâ€™s registered.\n    const valueType = /** @type {TokenType} */ (type + 'Value')\n    effects.enter(valueType)\n    effects.consume(code)\n    return shortcut\n  }\n\n  /** @type {State} */\n  function shortcut(code) {\n    if (\n      code === codes.eof ||\n      code === codes.quotationMark ||\n      code === codes.apostrophe ||\n      code === codes.lessThan ||\n      code === codes.equalsTo ||\n      code === codes.greaterThan ||\n      code === codes.graveAccent\n    ) {\n      return nok(code)\n    }\n\n    if (\n      code === codes.numberSign ||\n      code === codes.dot ||\n      code === codes.rightCurlyBrace ||\n      markdownLineEndingOrSpace(code)\n    ) {\n      // Assume itâ€™s registered.\n      const valueType = /** @type {TokenType} */ (type + 'Value')\n      effects.exit(valueType)\n      effects.exit(type)\n      effects.exit(attributeType)\n      return between(code)\n    }\n\n    effects.consume(code)\n    return shortcut\n  }\n\n  /** @type {State} */\n  function name(code) {\n    if (\n      code === codes.dash ||\n      code === codes.dot ||\n      code === codes.colon ||\n      code === codes.underscore ||\n      asciiAlphanumeric(code)\n    ) {\n      effects.consume(code)\n      return name\n    }\n\n    effects.exit(attributeNameType)\n\n    if (disallowEol && markdownSpace(code)) {\n      return factorySpace(effects, nameAfter, types.whitespace)(code)\n    }\n\n    if (!disallowEol && markdownLineEndingOrSpace(code)) {\n      return factoryWhitespace(effects, nameAfter)(code)\n    }\n\n    return nameAfter(code)\n  }\n\n  /** @type {State} */\n  function nameAfter(code) {\n    if (code === codes.equalsTo) {\n      effects.enter(attributeInitializerType)\n      effects.consume(code)\n      effects.exit(attributeInitializerType)\n      return valueBefore\n    }\n\n    // Attribute w/o value.\n    effects.exit(attributeType)\n    return between(code)\n  }\n\n  /** @type {State} */\n  function valueBefore(code) {\n    if (\n      code === codes.eof ||\n      code === codes.lessThan ||\n      code === codes.equalsTo ||\n      code === codes.greaterThan ||\n      code === codes.graveAccent ||\n      code === codes.rightCurlyBrace ||\n      (disallowEol && markdownLineEnding(code))\n    ) {\n      return nok(code)\n    }\n\n    if (code === codes.quotationMark || code === codes.apostrophe) {\n      effects.enter(attributeValueLiteralType)\n      effects.enter(attributeValueMarker)\n      effects.consume(code)\n      effects.exit(attributeValueMarker)\n      marker = code\n      return valueQuotedStart\n    }\n\n    if (disallowEol && markdownSpace(code)) {\n      return factorySpace(effects, valueBefore, types.whitespace)(code)\n    }\n\n    if (!disallowEol && markdownLineEndingOrSpace(code)) {\n      return factoryWhitespace(effects, valueBefore)(code)\n    }\n\n    effects.enter(attributeValueType)\n    effects.enter(attributeValueData)\n    effects.consume(code)\n    marker = undefined\n    return valueUnquoted\n  }\n\n  /** @type {State} */\n  function valueUnquoted(code) {\n    if (\n      code === codes.eof ||\n      code === codes.quotationMark ||\n      code === codes.apostrophe ||\n      code === codes.lessThan ||\n      code === codes.equalsTo ||\n      code === codes.greaterThan ||\n      code === codes.graveAccent\n    ) {\n      return nok(code)\n    }\n\n    if (code === codes.rightCurlyBrace || markdownLineEndingOrSpace(code)) {\n      effects.exit(attributeValueData)\n      effects.exit(attributeValueType)\n      effects.exit(attributeType)\n      return between(code)\n    }\n\n    effects.consume(code)\n    return valueUnquoted\n  }\n\n  /** @type {State} */\n  function valueQuotedStart(code) {\n    if (code === marker) {\n      effects.enter(attributeValueMarker)\n      effects.consume(code)\n      effects.exit(attributeValueMarker)\n      effects.exit(attributeValueLiteralType)\n      effects.exit(attributeType)\n      return valueQuotedAfter\n    }\n\n    effects.enter(attributeValueType)\n    return valueQuotedBetween(code)\n  }\n\n  /** @type {State} */\n  function valueQuotedBetween(code) {\n    if (code === marker) {\n      effects.exit(attributeValueType)\n      return valueQuotedStart(code)\n    }\n\n    if (code === codes.eof) {\n      return nok(code)\n    }\n\n    // Note: blank lines canâ€™t exist in content.\n    if (markdownLineEnding(code)) {\n      return disallowEol\n        ? nok(code)\n        : factoryWhitespace(effects, valueQuotedBetween)(code)\n    }\n\n    effects.enter(attributeValueData)\n    effects.consume(code)\n    return valueQuoted\n  }\n\n  /** @type {State} */\n  function valueQuoted(code) {\n    if (code === marker || code === codes.eof || markdownLineEnding(code)) {\n      effects.exit(attributeValueData)\n      return valueQuotedBetween(code)\n    }\n\n    effects.consume(code)\n    return valueQuoted\n  }\n\n  /** @type {State} */\n  function valueQuotedAfter(code) {\n    return code === codes.rightCurlyBrace || markdownLineEndingOrSpace(code)\n      ? between(code)\n      : end(code)\n  }\n\n  /** @type {State} */\n  function end(code) {\n    if (code === codes.rightCurlyBrace) {\n      effects.enter(attributesMarkerType)\n      effects.consume(code)\n      effects.exit(attributesMarkerType)\n      effects.exit(attributesType)\n      return ok\n    }\n\n    return nok(code)\n  }\n}\n", "/**\n * @typedef {import('micromark-util-types').Effects} Effects\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').TokenType} TokenType\n */\n\nimport {ok as assert} from 'uvu/assert'\nimport {markdownLineEnding} from 'micromark-util-character'\nimport {codes} from 'micromark-util-symbol/codes.js'\nimport {constants} from 'micromark-util-symbol/constants.js'\nimport {types} from 'micromark-util-symbol/types.js'\n\n// This is a fork of:\n// <https://github.com/micromark/micromark/tree/main/packages/micromark-factory-label>\n// to allow empty labels, balanced brackets (such as for nested directives),\n// text instead of strings, and optionally disallows EOLs.\n\n/**\n * @param {Effects} effects\n * @param {State} ok\n * @param {State} nok\n * @param {TokenType} type\n * @param {TokenType} markerType\n * @param {TokenType} stringType\n * @param {boolean} [disallowEol=false]\n */\n// eslint-disable-next-line max-params\nexport function factoryLabel(\n  effects,\n  ok,\n  nok,\n  type,\n  markerType,\n  stringType,\n  disallowEol\n) {\n  let size = 0\n  let balance = 0\n  /** @type {Token|undefined} */\n  let previous\n\n  return start\n\n  /** @type {State} */\n  function start(code) {\n    assert(code === codes.leftSquareBracket, 'expected `[`')\n    effects.enter(type)\n    effects.enter(markerType)\n    effects.consume(code)\n    effects.exit(markerType)\n    return afterStart\n  }\n\n  /** @type {State} */\n  function afterStart(code) {\n    if (code === codes.rightSquareBracket) {\n      effects.enter(markerType)\n      effects.consume(code)\n      effects.exit(markerType)\n      effects.exit(type)\n      return ok\n    }\n\n    effects.enter(stringType)\n    return lineStart(code)\n  }\n\n  /** @type {State} */\n  function lineStart(code) {\n    if (code === codes.rightSquareBracket && !balance) {\n      return atClosingBrace(code)\n    }\n\n    const token = effects.enter(types.chunkText, {\n      contentType: constants.contentTypeText,\n      previous\n    })\n    if (previous) previous.next = token\n    previous = token\n    return data(code)\n  }\n\n  /** @type {State} */\n  function data(code) {\n    if (code === codes.eof || size > constants.linkReferenceSizeMax) {\n      return nok(code)\n    }\n\n    if (\n      code === codes.leftSquareBracket &&\n      ++balance > constants.linkResourceDestinationBalanceMax\n    ) {\n      return nok(code)\n    }\n\n    if (code === codes.rightSquareBracket && !balance--) {\n      effects.exit(types.chunkText)\n      return atClosingBrace(code)\n    }\n\n    if (markdownLineEnding(code)) {\n      if (disallowEol) {\n        return nok(code)\n      }\n\n      effects.consume(code)\n      effects.exit(types.chunkText)\n      return lineStart\n    }\n\n    effects.consume(code)\n    return code === codes.backslash ? dataEscape : data\n  }\n\n  /** @type {State} */\n  function dataEscape(code) {\n    if (\n      code === codes.leftSquareBracket ||\n      code === codes.backslash ||\n      code === codes.rightSquareBracket\n    ) {\n      effects.consume(code)\n      size++\n      return data\n    }\n\n    return data(code)\n  }\n\n  /** @type {State} */\n  function atClosingBrace(code) {\n    effects.exit(stringType)\n    effects.enter(markerType)\n    effects.consume(code)\n    effects.exit(markerType)\n    effects.exit(type)\n    return ok\n  }\n}\n", "/**\n * @typedef {import('micromark-util-types').Effects} Effects\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').TokenType} TokenType\n */\n\nimport {asciiAlpha, asciiAlphanumeric} from 'micromark-util-character'\nimport {codes} from 'micromark-util-symbol/codes.js'\n\n/**\n * @this {TokenizeContext}\n * @param {Effects} effects\n * @param {State} ok\n * @param {State} nok\n * @param {TokenType} type\n */\nexport function factoryName(effects, ok, nok, type) {\n  const self = this\n\n  return start\n\n  /** @type {State} */\n  function start(code) {\n    if (asciiAlpha(code)) {\n      effects.enter(type)\n      effects.consume(code)\n      return name\n    }\n\n    return nok(code)\n  }\n\n  /** @type {State} */\n  function name(code) {\n    if (\n      code === codes.dash ||\n      code === codes.underscore ||\n      asciiAlphanumeric(code)\n    ) {\n      effects.consume(code)\n      return name\n    }\n\n    effects.exit(type)\n    return self.previous === codes.dash || self.previous === codes.underscore\n      ? nok(code)\n      : ok(code)\n  }\n}\n", "/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport {ok as assert} from 'uvu/assert'\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownLineEnding} from 'micromark-util-character'\nimport {codes} from 'micromark-util-symbol/codes.js'\nimport {constants} from 'micromark-util-symbol/constants.js'\nimport {types} from 'micromark-util-symbol/types.js'\nimport {factoryAttributes} from './factory-attributes.js'\nimport {factoryLabel} from './factory-label.js'\nimport {factoryName} from './factory-name.js'\n\n/** @type {Construct} */\nexport const directiveContainer = {\n  tokenize: tokenizeDirectiveContainer,\n  concrete: true\n}\n\nconst label = {tokenize: tokenizeLabel, partial: true}\nconst attributes = {tokenize: tokenizeAttributes, partial: true}\nconst nonLazyLine = {tokenize: tokenizeNonLazyLine, partial: true}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeDirectiveContainer(effects, ok, nok) {\n  const self = this\n  const tail = self.events[self.events.length - 1]\n  const initialSize =\n    tail && tail[1].type === types.linePrefix\n      ? tail[2].sliceSerialize(tail[1], true).length\n      : 0\n  let sizeOpen = 0\n  /** @type {Token} */\n  let previous\n\n  return start\n\n  /** @type {State} */\n  function start(code) {\n    assert(code === codes.colon, 'expected `:`')\n    effects.enter('directiveContainer')\n    effects.enter('directiveContainerFence')\n    effects.enter('directiveContainerSequence')\n    return sequenceOpen(code)\n  }\n\n  /** @type {State} */\n  function sequenceOpen(code) {\n    if (code === codes.colon) {\n      effects.consume(code)\n      sizeOpen++\n      return sequenceOpen\n    }\n\n    if (sizeOpen < constants.codeFencedSequenceSizeMin) {\n      return nok(code)\n    }\n\n    effects.exit('directiveContainerSequence')\n    return factoryName.call(\n      self,\n      effects,\n      afterName,\n      nok,\n      'directiveContainerName'\n    )(code)\n  }\n\n  /** @type {State} */\n  function afterName(code) {\n    return code === codes.leftSquareBracket\n      ? effects.attempt(label, afterLabel, afterLabel)(code)\n      : afterLabel(code)\n  }\n\n  /** @type {State} */\n  function afterLabel(code) {\n    return code === codes.leftCurlyBrace\n      ? effects.attempt(attributes, afterAttributes, afterAttributes)(code)\n      : afterAttributes(code)\n  }\n\n  /** @type {State} */\n  function afterAttributes(code) {\n    return factorySpace(effects, openAfter, types.whitespace)(code)\n  }\n\n  /** @type {State} */\n  function openAfter(code) {\n    effects.exit('directiveContainerFence')\n\n    if (code === codes.eof) {\n      return afterOpening(code)\n    }\n\n    if (markdownLineEnding(code)) {\n      if (self.interrupt) {\n        return ok(code)\n      }\n\n      return effects.attempt(nonLazyLine, contentStart, afterOpening)(code)\n    }\n\n    return nok(code)\n  }\n\n  /** @type {State} */\n  function afterOpening(code) {\n    effects.exit('directiveContainer')\n    return ok(code)\n  }\n\n  /** @type {State} */\n  function contentStart(code) {\n    if (code === codes.eof) {\n      effects.exit('directiveContainer')\n      return ok(code)\n    }\n\n    effects.enter('directiveContainerContent')\n    return lineStart(code)\n  }\n\n  /** @type {State} */\n  function lineStart(code) {\n    if (code === codes.eof) {\n      return after(code)\n    }\n\n    return effects.attempt(\n      {tokenize: tokenizeClosingFence, partial: true},\n      after,\n      initialSize\n        ? factorySpace(effects, chunkStart, types.linePrefix, initialSize + 1)\n        : chunkStart\n    )(code)\n  }\n\n  /** @type {State} */\n  function chunkStart(code) {\n    if (code === codes.eof) {\n      return after(code)\n    }\n\n    const token = effects.enter(types.chunkDocument, {\n      contentType: constants.contentTypeDocument,\n      previous\n    })\n    if (previous) previous.next = token\n    previous = token\n    return contentContinue(code)\n  }\n\n  /** @type {State} */\n  function contentContinue(code) {\n    if (code === codes.eof) {\n      const t = effects.exit(types.chunkDocument)\n      self.parser.lazy[t.start.line] = false\n      return after(code)\n    }\n\n    if (markdownLineEnding(code)) {\n      return effects.check(nonLazyLine, nonLazyLineAfter, lineAfter)(code)\n    }\n\n    effects.consume(code)\n    return contentContinue\n  }\n\n  /** @type {State} */\n  function nonLazyLineAfter(code) {\n    effects.consume(code)\n    const t = effects.exit(types.chunkDocument)\n    self.parser.lazy[t.start.line] = false\n    return lineStart\n  }\n\n  /** @type {State} */\n  function lineAfter(code) {\n    const t = effects.exit(types.chunkDocument)\n    self.parser.lazy[t.start.line] = false\n    return after(code)\n  }\n\n  /** @type {State} */\n  function after(code) {\n    effects.exit('directiveContainerContent')\n    effects.exit('directiveContainer')\n    return ok(code)\n  }\n\n  /**\n   * @this {TokenizeContext}\n   * @type {Tokenizer}\n   */\n  function tokenizeClosingFence(effects, ok, nok) {\n    let size = 0\n\n    return factorySpace(\n      effects,\n      closingPrefixAfter,\n      types.linePrefix,\n      constants.tabSize\n    )\n\n    /** @type {State} */\n    function closingPrefixAfter(code) {\n      effects.enter('directiveContainerFence')\n      effects.enter('directiveContainerSequence')\n      return closingSequence(code)\n    }\n\n    /** @type {State} */\n    function closingSequence(code) {\n      if (code === codes.colon) {\n        effects.consume(code)\n        size++\n        return closingSequence\n      }\n\n      if (size < sizeOpen) return nok(code)\n      effects.exit('directiveContainerSequence')\n      return factorySpace(effects, closingSequenceEnd, types.whitespace)(code)\n    }\n\n    /** @type {State} */\n    function closingSequenceEnd(code) {\n      if (code === codes.eof || markdownLineEnding(code)) {\n        effects.exit('directiveContainerFence')\n        return ok(code)\n      }\n\n      return nok(code)\n    }\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeLabel(effects, ok, nok) {\n  // Always a `[`\n  return factoryLabel(\n    effects,\n    ok,\n    nok,\n    'directiveContainerLabel',\n    'directiveContainerLabelMarker',\n    'directiveContainerLabelString',\n    true\n  )\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeAttributes(effects, ok, nok) {\n  // Always a `{`\n  return factoryAttributes(\n    effects,\n    ok,\n    nok,\n    'directiveContainerAttributes',\n    'directiveContainerAttributesMarker',\n    'directiveContainerAttribute',\n    'directiveContainerAttributeId',\n    'directiveContainerAttributeClass',\n    'directiveContainerAttributeName',\n    'directiveContainerAttributeInitializerMarker',\n    'directiveContainerAttributeValueLiteral',\n    'directiveContainerAttributeValue',\n    'directiveContainerAttributeValueMarker',\n    'directiveContainerAttributeValueData',\n    true\n  )\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeNonLazyLine(effects, ok, nok) {\n  const self = this\n\n  return start\n\n  /** @type {State} */\n  function start(code) {\n    assert(markdownLineEnding(code), 'expected eol')\n    effects.enter(types.lineEnding)\n    effects.consume(code)\n    effects.exit(types.lineEnding)\n    return lineStart\n  }\n\n  /** @type {State} */\n  function lineStart(code) {\n    return self.parser.lazy[self.now().line] ? nok(code) : ok(code)\n  }\n}\n", "/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport {ok as assert} from 'uvu/assert'\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownLineEnding} from 'micromark-util-character'\nimport {codes} from 'micromark-util-symbol/codes.js'\nimport {types} from 'micromark-util-symbol/types.js'\nimport {factoryAttributes} from './factory-attributes.js'\nimport {factoryLabel} from './factory-label.js'\nimport {factoryName} from './factory-name.js'\n\n/** @type {Construct} */\nexport const directiveLeaf = {tokenize: tokenizeDirectiveLeaf}\n\nconst label = {tokenize: tokenizeLabel, partial: true}\nconst attributes = {tokenize: tokenizeAttributes, partial: true}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeDirectiveLeaf(effects, ok, nok) {\n  const self = this\n\n  return start\n\n  /** @type {State} */\n  function start(code) {\n    assert(code === codes.colon, 'expected `:`')\n    effects.enter('directiveLeaf')\n    effects.enter('directiveLeafSequence')\n    effects.consume(code)\n    return inStart\n  }\n\n  /** @type {State} */\n  function inStart(code) {\n    if (code === codes.colon) {\n      effects.consume(code)\n      effects.exit('directiveLeafSequence')\n      return factoryName.call(\n        self,\n        effects,\n        afterName,\n        nok,\n        'directiveLeafName'\n      )\n    }\n\n    return nok(code)\n  }\n\n  /** @type {State} */\n  function afterName(code) {\n    return code === codes.leftSquareBracket\n      ? effects.attempt(label, afterLabel, afterLabel)(code)\n      : afterLabel(code)\n  }\n\n  /** @type {State} */\n  function afterLabel(code) {\n    return code === codes.leftCurlyBrace\n      ? effects.attempt(attributes, afterAttributes, afterAttributes)(code)\n      : afterAttributes(code)\n  }\n\n  /** @type {State} */\n  function afterAttributes(code) {\n    return factorySpace(effects, end, types.whitespace)(code)\n  }\n\n  /** @type {State} */\n  function end(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      effects.exit('directiveLeaf')\n      return ok(code)\n    }\n\n    return nok(code)\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeLabel(effects, ok, nok) {\n  // Always a `[`\n  return factoryLabel(\n    effects,\n    ok,\n    nok,\n    'directiveLeafLabel',\n    'directiveLeafLabelMarker',\n    'directiveLeafLabelString',\n    true\n  )\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeAttributes(effects, ok, nok) {\n  // Always a `{`\n  return factoryAttributes(\n    effects,\n    ok,\n    nok,\n    'directiveLeafAttributes',\n    'directiveLeafAttributesMarker',\n    'directiveLeafAttribute',\n    'directiveLeafAttributeId',\n    'directiveLeafAttributeClass',\n    'directiveLeafAttributeName',\n    'directiveLeafAttributeInitializerMarker',\n    'directiveLeafAttributeValueLiteral',\n    'directiveLeafAttributeValue',\n    'directiveLeafAttributeValueMarker',\n    'directiveLeafAttributeValueData',\n    true\n  )\n}\n", "/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Previous} Previous\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport {ok as assert} from 'uvu/assert'\nimport {codes} from 'micromark-util-symbol/codes.js'\nimport {types} from 'micromark-util-symbol/types.js'\nimport {factoryAttributes} from './factory-attributes.js'\nimport {factoryLabel} from './factory-label.js'\nimport {factoryName} from './factory-name.js'\n\n/** @type {Construct} */\nexport const directiveText = {\n  tokenize: tokenizeDirectiveText,\n  previous\n}\n\nconst label = {tokenize: tokenizeLabel, partial: true}\nconst attributes = {tokenize: tokenizeAttributes, partial: true}\n\n/**\n * @this {TokenizeContext}\n * @type {Previous}\n */\nfunction previous(code) {\n  // If there is a previous code, there will always be a tail.\n  return (\n    code !== codes.colon ||\n    this.events[this.events.length - 1][1].type === types.characterEscape\n  )\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeDirectiveText(effects, ok, nok) {\n  const self = this\n\n  return start\n\n  /** @type {State} */\n  function start(code) {\n    assert(code === codes.colon, 'expected `:`')\n    assert(previous.call(self, self.previous), 'expected correct previous')\n    effects.enter('directiveText')\n    effects.enter('directiveTextMarker')\n    effects.consume(code)\n    effects.exit('directiveTextMarker')\n    return factoryName.call(self, effects, afterName, nok, 'directiveTextName')\n  }\n\n  /** @type {State} */\n  function afterName(code) {\n    return code === codes.colon\n      ? nok(code)\n      : code === codes.leftSquareBracket\n      ? effects.attempt(label, afterLabel, afterLabel)(code)\n      : afterLabel(code)\n  }\n\n  /** @type {State} */\n  function afterLabel(code) {\n    return code === codes.leftCurlyBrace\n      ? effects.attempt(attributes, afterAttributes, afterAttributes)(code)\n      : afterAttributes(code)\n  }\n\n  /** @type {State} */\n  function afterAttributes(code) {\n    effects.exit('directiveText')\n    return ok(code)\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeLabel(effects, ok, nok) {\n  // Always a `[`\n  return factoryLabel(\n    effects,\n    ok,\n    nok,\n    'directiveTextLabel',\n    'directiveTextLabelMarker',\n    'directiveTextLabelString'\n  )\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeAttributes(effects, ok, nok) {\n  // Always a `{`\n  return factoryAttributes(\n    effects,\n    ok,\n    nok,\n    'directiveTextAttributes',\n    'directiveTextAttributesMarker',\n    'directiveTextAttribute',\n    'directiveTextAttributeId',\n    'directiveTextAttributeClass',\n    'directiveTextAttributeName',\n    'directiveTextAttributeInitializerMarker',\n    'directiveTextAttributeValueLiteral',\n    'directiveTextAttributeValue',\n    'directiveTextAttributeValueMarker',\n    'directiveTextAttributeValueData'\n  )\n}\n", "/**\n * @typedef {import('micromark-util-types').Extension} Extension\n */\n\nimport {codes} from 'micromark-util-symbol/codes.js'\nimport {directiveContainer} from './directive-container.js'\nimport {directiveLeaf} from './directive-leaf.js'\nimport {directiveText} from './directive-text.js'\n\n/**\n * Create an extension for `micromark` to enable directive syntax.\n *\n * @returns {Extension}\n *   Extension for `micromark` that can be passed in `extensions`, to\n *   enable directive syntax.\n */\nexport function directive() {\n  return {\n    text: {[codes.colon]: directiveText},\n    flow: {[codes.colon]: [directiveContainer, directiveLeaf]}\n  }\n}\n", "/**\n * List of legacy HTML named character references that donâ€™t need a trailing semicolon.\n *\n * @type {Array<string>}\n */\nexport const characterEntitiesLegacy = [\n  'AElig',\n  'AMP',\n  'Aacute',\n  'Acirc',\n  'Agrave',\n  'Aring',\n  'Atilde',\n  'Auml',\n  'COPY',\n  'Ccedil',\n  'ETH',\n  'Eacute',\n  'Ecirc',\n  'Egrave',\n  'Euml',\n  'GT',\n  'Iacute',\n  'Icirc',\n  'Igrave',\n  'Iuml',\n  'LT',\n  'Ntilde',\n  'Oacute',\n  'Ocirc',\n  'Ograve',\n  'Oslash',\n  'Otilde',\n  'Ouml',\n  'QUOT',\n  'REG',\n  'THORN',\n  'Uacute',\n  'Ucirc',\n  'Ugrave',\n  'Uuml',\n  'Yacute',\n  'aacute',\n  'acirc',\n  'acute',\n  'aelig',\n  'agrave',\n  'amp',\n  'aring',\n  'atilde',\n  'auml',\n  'brvbar',\n  'ccedil',\n  'cedil',\n  'cent',\n  'copy',\n  'curren',\n  'deg',\n  'divide',\n  'eacute',\n  'ecirc',\n  'egrave',\n  'eth',\n  'euml',\n  'frac12',\n  'frac14',\n  'frac34',\n  'gt',\n  'iacute',\n  'icirc',\n  'iexcl',\n  'igrave',\n  'iquest',\n  'iuml',\n  'laquo',\n  'lt',\n  'macr',\n  'micro',\n  'middot',\n  'nbsp',\n  'not',\n  'ntilde',\n  'oacute',\n  'ocirc',\n  'ograve',\n  'ordf',\n  'ordm',\n  'oslash',\n  'otilde',\n  'ouml',\n  'para',\n  'plusmn',\n  'pound',\n  'quot',\n  'raquo',\n  'reg',\n  'sect',\n  'shy',\n  'sup1',\n  'sup2',\n  'sup3',\n  'szlig',\n  'thorn',\n  'times',\n  'uacute',\n  'ucirc',\n  'ugrave',\n  'uml',\n  'uuml',\n  'yacute',\n  'yen',\n  'yuml'\n]\n", "/**\n * Map of invalid numeric character references to their replacements, according to HTML.\n *\n * @type {Record<number, string>}\n */\nexport const characterReferenceInvalid = {\n  0: 'ï¿½',\n  128: 'â‚¬',\n  130: 'â€š',\n  131: 'Æ’',\n  132: 'â€ž',\n  133: 'â€¦',\n  134: 'â€ ',\n  135: 'â€¡',\n  136: 'Ë†',\n  137: 'â€°',\n  138: 'Å ',\n  139: 'â€¹',\n  140: 'Å’',\n  142: 'Å½',\n  145: 'â€˜',\n  146: 'â€™',\n  147: 'â€œ',\n  148: 'â€',\n  149: 'â€¢',\n  150: 'â€“',\n  151: 'â€”',\n  152: 'Ëœ',\n  153: 'â„¢',\n  154: 'Å¡',\n  155: 'â€º',\n  156: 'Å“',\n  158: 'Å¾',\n  159: 'Å¸'\n}\n", "/**\n * Check if the given character code, or the character code at the first\n * character, is decimal.\n *\n * @param {string|number} character\n * @returns {boolean} Whether `character` is a decimal\n */\nexport function isDecimal(character) {\n  const code =\n    typeof character === 'string' ? character.charCodeAt(0) : character\n\n  return code >= 48 && code <= 57 /* 0-9 */\n}\n", "/**\n * Check if the given character code, or the character code at the first\n * character, is hexadecimal.\n *\n * @param {string|number} character\n * @returns {boolean} Whether `character` is hexadecimal\n */\nexport function isHexadecimal(character) {\n  const code =\n    typeof character === 'string' ? character.charCodeAt(0) : character\n\n  return (\n    (code >= 97 /* a */ && code <= 102) /* z */ ||\n    (code >= 65 /* A */ && code <= 70) /* Z */ ||\n    (code >= 48 /* A */ && code <= 57) /* Z */\n  )\n}\n", "/**\n * Check if the given character code, or the character code at the first\n * character, is alphabetical.\n *\n * @param {string|number} character\n * @returns {boolean} Whether `character` is alphabetical.\n */\nexport function isAlphabetical(character) {\n  const code =\n    typeof character === 'string' ? character.charCodeAt(0) : character\n\n  return (\n    (code >= 97 && code <= 122) /* a-z */ ||\n    (code >= 65 && code <= 90) /* A-Z */\n  )\n}\n", "import {isAlphabetical} from 'is-alphabetical'\nimport {isDecimal} from 'is-decimal'\n\n/**\n * Check if the given character code, or the character code at the first\n * character, is alphanumerical.\n *\n * @param {string|number} character\n * @returns {boolean} Whether `character` is alphanumerical.\n */\nexport function isAlphanumerical(character) {\n  return isAlphabetical(character) || isDecimal(character)\n}\n", "/**\n * @typedef {import('unist').Point} Point\n * @typedef {import('unist').Position} Position\n */\n\nimport {characterEntitiesLegacy} from 'character-entities-legacy'\nimport {characterReferenceInvalid} from 'character-reference-invalid'\nimport {isDecimal} from 'is-decimal'\nimport {isHexadecimal} from 'is-hexadecimal'\nimport {isAlphanumerical} from 'is-alphanumerical'\nimport {decodeNamedCharacterReference} from 'decode-named-character-reference'\n\nconst fromCharCode = String.fromCharCode\n\n// Warning messages.\nconst messages = [\n  '',\n  /* 1: Non terminated (named) */\n  'Named character references must be terminated by a semicolon',\n  /* 2: Non terminated (numeric) */\n  'Numeric character references must be terminated by a semicolon',\n  /* 3: Empty (named) */\n  'Named character references cannot be empty',\n  /* 4: Empty (numeric) */\n  'Numeric character references cannot be empty',\n  /* 5: Unknown (named) */\n  'Named character references must be known',\n  /* 6: Disallowed (numeric) */\n  'Numeric character references cannot be disallowed',\n  /* 7: Prohibited (numeric) */\n  'Numeric character references cannot be outside the permissible Unicode range'\n]\n\n/**\n * Parse HTML character references.\n *\n * @param {string} value\n * @param {import('../index.js').Options} [options={}]\n */\nexport function parseEntities(value, options = {}) {\n  const additional =\n    typeof options.additional === 'string'\n      ? options.additional.charCodeAt(0)\n      : options.additional\n  /** @type {Array<string>} */\n  const result = []\n  let index = 0\n  let lines = -1\n  let queue = ''\n  /** @type {Point|undefined} */\n  let point\n  /** @type {Array<number>|undefined} */\n  let indent\n\n  if (options.position) {\n    if ('start' in options.position || 'indent' in options.position) {\n      // @ts-expect-error: points donâ€™t have indent.\n      indent = options.position.indent\n      // @ts-expect-error: points donâ€™t have indent.\n      point = options.position.start\n    } else {\n      point = options.position\n    }\n  }\n\n  let line = (point ? point.line : 0) || 1\n  let column = (point ? point.column : 0) || 1\n\n  // Cache the current point.\n  let previous = now()\n  /** @type {number|undefined} */\n  let character\n\n  // Ensure the algorithm walks over the first character (inclusive).\n  index--\n\n  while (++index <= value.length) {\n    // If the previous character was a newline.\n    if (character === 10 /* `\\n` */) {\n      column = (indent ? indent[lines] : 0) || 1\n    }\n\n    character = value.charCodeAt(index)\n\n    if (character === 38 /* `&` */) {\n      const following = value.charCodeAt(index + 1)\n\n      // The behavior depends on the identity of the next character.\n      if (\n        following === 9 /* `\\t` */ ||\n        following === 10 /* `\\n` */ ||\n        following === 12 /* `\\f` */ ||\n        following === 32 /* ` ` */ ||\n        following === 38 /* `&` */ ||\n        following === 60 /* `<` */ ||\n        Number.isNaN(following) ||\n        (additional && following === additional)\n      ) {\n        // Not a character reference.\n        // No characters are consumed, and nothing is returned.\n        // This is not an error, either.\n        queue += fromCharCode(character)\n        column++\n        continue\n      }\n\n      const start = index + 1\n      let begin = start\n      let end = start\n      /** @type {string} */\n      let type\n\n      if (following === 35 /* `#` */) {\n        // Numerical reference.\n        end = ++begin\n\n        // The behavior further depends on the next character.\n        const following = value.charCodeAt(end)\n\n        if (following === 88 /* `X` */ || following === 120 /* `x` */) {\n          // ASCII hexadecimal digits.\n          type = 'hexadecimal'\n          end = ++begin\n        } else {\n          // ASCII decimal digits.\n          type = 'decimal'\n        }\n      } else {\n        // Named reference.\n        type = 'named'\n      }\n\n      let characterReferenceCharacters = ''\n      let characterReference = ''\n      let characters = ''\n      // Each type of character reference accepts different characters.\n      // This test is used to detect whether a reference has ended (as the semicolon\n      // is not strictly needed).\n      const test =\n        type === 'named'\n          ? isAlphanumerical\n          : type === 'decimal'\n          ? isDecimal\n          : isHexadecimal\n\n      end--\n\n      while (++end <= value.length) {\n        const following = value.charCodeAt(end)\n\n        if (!test(following)) {\n          break\n        }\n\n        characters += fromCharCode(following)\n\n        // Check if we can match a legacy named reference.\n        // If so, we cache that as the last viable named reference.\n        // This ensures we do not need to walk backwards later.\n        if (type === 'named' && characterEntitiesLegacy.includes(characters)) {\n          characterReferenceCharacters = characters\n          // @ts-expect-error: always able to decode.\n          characterReference = decodeNamedCharacterReference(characters)\n        }\n      }\n\n      let terminated = value.charCodeAt(end) === 59 /* `;` */\n\n      if (terminated) {\n        end++\n\n        const namedReference =\n          type === 'named' ? decodeNamedCharacterReference(characters) : false\n\n        if (namedReference) {\n          characterReferenceCharacters = characters\n          characterReference = namedReference\n        }\n      }\n\n      let diff = 1 + end - start\n      let reference = ''\n\n      if (!terminated && options.nonTerminated === false) {\n        // Empty.\n      } else if (!characters) {\n        // An empty (possible) reference is valid, unless itâ€™s numeric (thus an\n        // ampersand followed by an octothorp).\n        if (type !== 'named') {\n          warning(4 /* Empty (numeric) */, diff)\n        }\n      } else if (type === 'named') {\n        // An ampersand followed by anything unknown, and not terminated, is\n        // invalid.\n        if (terminated && !characterReference) {\n          warning(5 /* Unknown (named) */, 1)\n        } else {\n          // If thereâ€™s something after an named reference which is not known,\n          // cap the reference.\n          if (characterReferenceCharacters !== characters) {\n            end = begin + characterReferenceCharacters.length\n            diff = 1 + end - begin\n            terminated = false\n          }\n\n          // If the reference is not terminated, warn.\n          if (!terminated) {\n            const reason = characterReferenceCharacters\n              ? 1 /* Non terminated (named) */\n              : 3 /* Empty (named) */\n\n            if (options.attribute) {\n              const following = value.charCodeAt(end)\n\n              if (following === 61 /* `=` */) {\n                warning(reason, diff)\n                characterReference = ''\n              } else if (isAlphanumerical(following)) {\n                characterReference = ''\n              } else {\n                warning(reason, diff)\n              }\n            } else {\n              warning(reason, diff)\n            }\n          }\n        }\n\n        reference = characterReference\n      } else {\n        if (!terminated) {\n          // All nonterminated numeric references are not rendered, and emit a\n          // warning.\n          warning(2 /* Non terminated (numeric) */, diff)\n        }\n\n        // When terminated and numerical, parse as either hexadecimal or\n        // decimal.\n        let referenceCode = Number.parseInt(\n          characters,\n          type === 'hexadecimal' ? 16 : 10\n        )\n\n        // Emit a warning when the parsed number is prohibited, and replace with\n        // replacement character.\n        if (prohibited(referenceCode)) {\n          warning(7 /* Prohibited (numeric) */, diff)\n          reference = fromCharCode(65533 /* `ï¿½` */)\n        } else if (referenceCode in characterReferenceInvalid) {\n          // Emit a warning when the parsed number is disallowed, and replace by\n          // an alternative.\n          warning(6 /* Disallowed (numeric) */, diff)\n          reference = characterReferenceInvalid[referenceCode]\n        } else {\n          // Parse the number.\n          let output = ''\n\n          // Emit a warning when the parsed number should not be used.\n          if (disallowed(referenceCode)) {\n            warning(6 /* Disallowed (numeric) */, diff)\n          }\n\n          // Serialize the number.\n          if (referenceCode > 0xffff) {\n            referenceCode -= 0x10000\n            output += fromCharCode((referenceCode >>> (10 & 0x3ff)) | 0xd800)\n            referenceCode = 0xdc00 | (referenceCode & 0x3ff)\n          }\n\n          reference = output + fromCharCode(referenceCode)\n        }\n      }\n\n      // Found it!\n      // First eat the queued characters as normal text, then eat a reference.\n      if (reference) {\n        flush()\n\n        previous = now()\n        index = end - 1\n        column += end - start + 1\n        result.push(reference)\n        const next = now()\n        next.offset++\n\n        if (options.reference) {\n          options.reference.call(\n            options.referenceContext,\n            reference,\n            {start: previous, end: next},\n            value.slice(start - 1, end)\n          )\n        }\n\n        previous = next\n      } else {\n        // If we could not find a reference, queue the checked characters (as\n        // normal characters), and move the pointer to their end.\n        // This is possible because we can be certain neither newlines nor\n        // ampersands are included.\n        characters = value.slice(start - 1, end)\n        queue += characters\n        column += characters.length\n        index = end - 1\n      }\n    } else {\n      // Handle anything other than an ampersand, including newlines and EOF.\n      if (character === 10 /* `\\n` */) {\n        line++\n        lines++\n        column = 0\n      }\n\n      if (Number.isNaN(character)) {\n        flush()\n      } else {\n        queue += fromCharCode(character)\n        column++\n      }\n    }\n  }\n\n  // Return the reduced nodes.\n  return result.join('')\n\n  // Get current position.\n  function now() {\n    return {\n      line,\n      column,\n      offset: index + ((point ? point.offset : 0) || 0)\n    }\n  }\n\n  /**\n   * Handle the warning.\n   *\n   * @param {1|2|3|4|5|6|7} code\n   * @param {number} offset\n   */\n  function warning(code, offset) {\n    /** @type {ReturnType<now>} */\n    let position\n\n    if (options.warning) {\n      position = now()\n      position.column += offset\n      position.offset += offset\n\n      options.warning.call(\n        options.warningContext,\n        messages[code],\n        position,\n        code\n      )\n    }\n  }\n\n  /**\n   * Flush `queue` (normal text).\n   * Macro invoked before each reference and at the end of `value`.\n   * Does nothing when `queue` is empty.\n   */\n  function flush() {\n    if (queue) {\n      result.push(queue)\n\n      if (options.text) {\n        options.text.call(options.textContext, queue, {\n          start: previous,\n          end: now()\n        })\n      }\n\n      queue = ''\n    }\n  }\n}\n\n/**\n * Check if `character` is outside the permissible unicode range.\n *\n * @param {number} code\n * @returns {boolean}\n */\nfunction prohibited(code) {\n  return (code >= 0xd800 && code <= 0xdfff) || code > 0x10ffff\n}\n\n/**\n * Check if `character` is disallowed.\n *\n * @param {number} code\n * @returns {boolean}\n */\nfunction disallowed(code) {\n  return (\n    (code >= 0x0001 && code <= 0x0008) ||\n    code === 0x000b ||\n    (code >= 0x000d && code <= 0x001f) ||\n    (code >= 0x007f && code <= 0x009f) ||\n    (code >= 0xfdd0 && code <= 0xfdef) ||\n    (code & 0xffff) === 0xffff ||\n    (code & 0xffff) === 0xfffe\n  )\n}\n", "/**\n * @typedef {import('micromark-util-types').CompileContext} CompileContext\n * @typedef {import('micromark-util-types').Handle} _Handle\n * @typedef {import('micromark-util-types').HtmlExtension} HtmlExtension\n */\n\n/**\n * @typedef {[string, string]} Attribute\n *   Internal tuple representing an attribute.\n */\n\n/**\n * @typedef {Record<string, Handle>} HtmlOptions\n *   Configuration.\n *\n *   > ðŸ‘‰ **Note**: the special field `'*'` can be used to specify a fallback\n *   > handle to handle all otherwise unhandled directives.\n *\n * @callback Handle\n *   Handle a directive.\n * @param {CompileContext} this\n *   Current context.\n * @param {Directive} directive\n *   Directive.\n * @returns {boolean | void}\n *   Signal whether the directive was handled.\n *   Yield `false` to let the fallback (a special handle for `'*'`) handle it.\n *\n * @typedef Directive\n *   Structure representing a directive.\n * @property {DirectiveType} type\n *   Kind.\n * @property {string} name\n *   Name of directive.\n * @property {string | undefined} [label]\n *   Compiled HTML content that was in `[brackets]`.\n * @property {Record<string, string> | undefined} [attributes]\n *   Object w/ HTML attributes.\n * @property {string | undefined} [content]\n *   Compiled HTML content inside container directive.\n * @property {number | undefined} [_fenceCount]\n *   Private :)\n *\n * @typedef {'containerDirective' | 'leafDirective' | 'textDirective'} DirectiveType\n *   Kind.\n */\n\nimport {ok as assert} from 'uvu/assert'\nimport {parseEntities} from 'parse-entities'\n\nconst own = {}.hasOwnProperty\n\n/**\n * Create an extension for `micromark` to support directives when serializing\n * to HTML.\n *\n * @param {HtmlOptions | null | undefined} [options]\n *   Configuration.\n * @returns {HtmlExtension}\n *   Extension for `micromark` that can be passed in `htmlExtensions`, to\n *   support directives when serializing to HTML.\n */\nexport function directiveHtml(options) {\n  const options_ = options || {}\n  return {\n    enter: {\n      directiveContainer() {\n        return enter.call(this, 'containerDirective')\n      },\n      directiveContainerAttributes: enterAttributes,\n      directiveContainerLabel: enterLabel,\n      directiveContainerContent() {\n        this.buffer()\n      },\n\n      directiveLeaf() {\n        return enter.call(this, 'leafDirective')\n      },\n      directiveLeafAttributes: enterAttributes,\n      directiveLeafLabel: enterLabel,\n\n      directiveText() {\n        return enter.call(this, 'textDirective')\n      },\n      directiveTextAttributes: enterAttributes,\n      directiveTextLabel: enterLabel\n    },\n    exit: {\n      directiveContainer: exit,\n      directiveContainerAttributeClassValue: exitAttributeClassValue,\n      directiveContainerAttributeIdValue: exitAttributeIdValue,\n      directiveContainerAttributeName: exitAttributeName,\n      directiveContainerAttributeValue: exitAttributeValue,\n      directiveContainerAttributes: exitAttributes,\n      directiveContainerContent: exitContainerContent,\n      directiveContainerFence: exitContainerFence,\n      directiveContainerLabel: exitLabel,\n      directiveContainerName: exitName,\n\n      directiveLeaf: exit,\n      directiveLeafAttributeClassValue: exitAttributeClassValue,\n      directiveLeafAttributeIdValue: exitAttributeIdValue,\n      directiveLeafAttributeName: exitAttributeName,\n      directiveLeafAttributeValue: exitAttributeValue,\n      directiveLeafAttributes: exitAttributes,\n      directiveLeafLabel: exitLabel,\n      directiveLeafName: exitName,\n\n      directiveText: exit,\n      directiveTextAttributeClassValue: exitAttributeClassValue,\n      directiveTextAttributeIdValue: exitAttributeIdValue,\n      directiveTextAttributeName: exitAttributeName,\n      directiveTextAttributeValue: exitAttributeValue,\n      directiveTextAttributes: exitAttributes,\n      directiveTextLabel: exitLabel,\n      directiveTextName: exitName\n    }\n  }\n\n  /**\n   * @this {CompileContext}\n   * @param {DirectiveType} type\n   */\n  function enter(type) {\n    let stack = this.getData('directiveStack')\n    if (!stack) this.setData('directiveStack', (stack = []))\n    stack.push({type, name: ''})\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {_Handle}\n   */\n  function exitName(token) {\n    const stack = this.getData('directiveStack')\n    assert(stack, 'expected directive stack')\n    stack[stack.length - 1].name = this.sliceSerialize(token)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {_Handle}\n   */\n  function enterLabel() {\n    this.buffer()\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {_Handle}\n   */\n  function exitLabel() {\n    const data = this.resume()\n    const stack = this.getData('directiveStack')\n    assert(stack, 'expected directive stack')\n    stack[stack.length - 1].label = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {_Handle}\n   */\n  function enterAttributes() {\n    this.buffer()\n    this.setData('directiveAttributes', [])\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {_Handle}\n   */\n  function exitAttributeIdValue(token) {\n    const attributes = this.getData('directiveAttributes')\n    assert(attributes, 'expected attributes')\n    attributes.push([\n      'id',\n      parseEntities(this.sliceSerialize(token), {\n        attribute: true\n      })\n    ])\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {_Handle}\n   */\n  function exitAttributeClassValue(token) {\n    const attributes = this.getData('directiveAttributes')\n    assert(attributes, 'expected attributes')\n\n    attributes.push([\n      'class',\n      parseEntities(this.sliceSerialize(token), {\n        attribute: true\n      })\n    ])\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {_Handle}\n   */\n  function exitAttributeName(token) {\n    // Attribute names in CommonMark are significantly limited, so character\n    // references canâ€™t exist.\n    const attributes = this.getData('directiveAttributes')\n    assert(attributes, 'expected attributes')\n\n    attributes.push([this.sliceSerialize(token), ''])\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {_Handle}\n   */\n  function exitAttributeValue(token) {\n    const attributes = this.getData('directiveAttributes')\n    assert(attributes, 'expected attributes')\n    attributes[attributes.length - 1][1] = parseEntities(\n      this.sliceSerialize(token),\n      {attribute: true}\n    )\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {_Handle}\n   */\n  function exitAttributes() {\n    const stack = this.getData('directiveStack')\n    assert(stack, 'expected directive stack')\n    const attributes = this.getData('directiveAttributes')\n    assert(attributes, 'expected attributes')\n    /** @type {Directive['attributes']} */\n    const cleaned = {}\n    let index = -1\n\n    while (++index < attributes.length) {\n      const attribute = attributes[index]\n\n      if (attribute[0] === 'class' && cleaned.class) {\n        cleaned.class += ' ' + attribute[1]\n      } else {\n        cleaned[attribute[0]] = attribute[1]\n      }\n    }\n\n    this.resume()\n    this.setData('directiveAttributes')\n    stack[stack.length - 1].attributes = cleaned\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {_Handle}\n   */\n  function exitContainerContent() {\n    const data = this.resume()\n    const stack = this.getData('directiveStack')\n    assert(stack, 'expected directive stack')\n    stack[stack.length - 1].content = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {_Handle}\n   */\n  function exitContainerFence() {\n    const stack = this.getData('directiveStack')\n    assert(stack, 'expected directive stack')\n    const directive = stack[stack.length - 1]\n    if (!directive._fenceCount) directive._fenceCount = 0\n    directive._fenceCount++\n    if (directive._fenceCount === 1) this.setData('slurpOneLineEnding', true)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {_Handle}\n   */\n  function exit() {\n    const stack = this.getData('directiveStack')\n    assert(stack, 'expected directive stack')\n    const directive = stack.pop()\n    assert(directive, 'expected directive')\n    /** @type {boolean|undefined} */\n    let found\n    /** @type {boolean|void} */\n    let result\n\n    assert(directive.name, 'expected `name`')\n\n    if (own.call(options_, directive.name)) {\n      result = options_[directive.name].call(this, directive)\n      found = result !== false\n    }\n\n    if (!found && own.call(options_, '*')) {\n      result = options_['*'].call(this, directive)\n      found = result !== false\n    }\n\n    if (!found && directive.type !== 'textDirective') {\n      this.setData('slurpOneLineEnding', true)\n    }\n  }\n}\n", "/**\n * @typedef CoreOptions\n * @property {ReadonlyArray<string>} [subset=[]]\n *   Whether to only escape the given subset of characters.\n * @property {boolean} [escapeOnly=false]\n *   Whether to only escape possibly dangerous characters.\n *   Those characters are `\"`, `&`, `'`, `<`, `>`, and `` ` ``.\n *\n * @typedef FormatOptions\n * @property {(code: number, next: number, options: CoreWithFormatOptions) => string} format\n *   Format strategy.\n *\n * @typedef {CoreOptions & FormatOptions & import('./util/format-smart.js').FormatSmartOptions} CoreWithFormatOptions\n */\n\nconst defaultSubsetRegex = /[\"&'<>`]/g\nconst surrogatePairsRegex = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g\nconst controlCharactersRegex =\n  // eslint-disable-next-line no-control-regex, unicorn/no-hex-escape\n  /[\\x01-\\t\\v\\f\\x0E-\\x1F\\x7F\\x81\\x8D\\x8F\\x90\\x9D\\xA0-\\uFFFF]/g\nconst regexEscapeRegex = /[|\\\\{}()[\\]^$+*?.]/g\n\n/** @type {WeakMap<ReadonlyArray<string>, RegExp>} */\nconst subsetToRegexCache = new WeakMap()\n\n/**\n * Encode certain characters in `value`.\n *\n * @param {string} value\n * @param {CoreWithFormatOptions} options\n * @returns {string}\n */\nexport function core(value, options) {\n  value = value.replace(\n    options.subset\n      ? charactersToExpressionCached(options.subset)\n      : defaultSubsetRegex,\n    basic\n  )\n\n  if (options.subset || options.escapeOnly) {\n    return value\n  }\n\n  return (\n    value\n      // Surrogate pairs.\n      .replace(surrogatePairsRegex, surrogate)\n      // BMP control characters (C0 except for LF, CR, SP; DEL; and some more\n      // non-ASCII ones).\n      .replace(controlCharactersRegex, basic)\n  )\n\n  /**\n   * @param {string} pair\n   * @param {number} index\n   * @param {string} all\n   */\n  function surrogate(pair, index, all) {\n    return options.format(\n      (pair.charCodeAt(0) - 0xd800) * 0x400 +\n        pair.charCodeAt(1) -\n        0xdc00 +\n        0x10000,\n      all.charCodeAt(index + 2),\n      options\n    )\n  }\n\n  /**\n   * @param {string} character\n   * @param {number} index\n   * @param {string} all\n   */\n  function basic(character, index, all) {\n    return options.format(\n      character.charCodeAt(0),\n      all.charCodeAt(index + 1),\n      options\n    )\n  }\n}\n\n/**\n * A wrapper function that caches the result of `charactersToExpression` with a WeakMap.\n * This can improve performance when tooling calls `charactersToExpression` repeatedly\n * with the same subset.\n *\n * @param {ReadonlyArray<string>} subset\n * @returns {RegExp}\n */\nfunction charactersToExpressionCached(subset) {\n  let cached = subsetToRegexCache.get(subset)\n\n  if (!cached) {\n    cached = charactersToExpression(subset)\n    subsetToRegexCache.set(subset, cached)\n  }\n\n  return cached\n}\n\n/**\n * @param {ReadonlyArray<string>} subset\n * @returns {RegExp}\n */\nfunction charactersToExpression(subset) {\n  /** @type {Array<string>} */\n  const groups = []\n  let index = -1\n\n  while (++index < subset.length) {\n    groups.push(subset[index].replace(regexEscapeRegex, '\\\\$&'))\n  }\n\n  return new RegExp('(?:' + groups.join('|') + ')', 'g')\n}\n", "/**\n * Map of named character references from HTML 4.\n *\n * @type {Record<string, string>}\n */\nexport const characterEntitiesHtml4 = {\n  nbsp: 'Â ',\n  iexcl: 'Â¡',\n  cent: 'Â¢',\n  pound: 'Â£',\n  curren: 'Â¤',\n  yen: 'Â¥',\n  brvbar: 'Â¦',\n  sect: 'Â§',\n  uml: 'Â¨',\n  copy: 'Â©',\n  ordf: 'Âª',\n  laquo: 'Â«',\n  not: 'Â¬',\n  shy: 'Â­',\n  reg: 'Â®',\n  macr: 'Â¯',\n  deg: 'Â°',\n  plusmn: 'Â±',\n  sup2: 'Â²',\n  sup3: 'Â³',\n  acute: 'Â´',\n  micro: 'Âµ',\n  para: 'Â¶',\n  middot: 'Â·',\n  cedil: 'Â¸',\n  sup1: 'Â¹',\n  ordm: 'Âº',\n  raquo: 'Â»',\n  frac14: 'Â¼',\n  frac12: 'Â½',\n  frac34: 'Â¾',\n  iquest: 'Â¿',\n  Agrave: 'Ã€',\n  Aacute: 'Ã',\n  Acirc: 'Ã‚',\n  Atilde: 'Ãƒ',\n  Auml: 'Ã„',\n  Aring: 'Ã…',\n  AElig: 'Ã†',\n  Ccedil: 'Ã‡',\n  Egrave: 'Ãˆ',\n  Eacute: 'Ã‰',\n  Ecirc: 'ÃŠ',\n  Euml: 'Ã‹',\n  Igrave: 'ÃŒ',\n  Iacute: 'Ã',\n  Icirc: 'ÃŽ',\n  Iuml: 'Ã',\n  ETH: 'Ã',\n  Ntilde: 'Ã‘',\n  Ograve: 'Ã’',\n  Oacute: 'Ã“',\n  Ocirc: 'Ã”',\n  Otilde: 'Ã•',\n  Ouml: 'Ã–',\n  times: 'Ã—',\n  Oslash: 'Ã˜',\n  Ugrave: 'Ã™',\n  Uacute: 'Ãš',\n  Ucirc: 'Ã›',\n  Uuml: 'Ãœ',\n  Yacute: 'Ã',\n  THORN: 'Ãž',\n  szlig: 'ÃŸ',\n  agrave: 'Ã ',\n  aacute: 'Ã¡',\n  acirc: 'Ã¢',\n  atilde: 'Ã£',\n  auml: 'Ã¤',\n  aring: 'Ã¥',\n  aelig: 'Ã¦',\n  ccedil: 'Ã§',\n  egrave: 'Ã¨',\n  eacute: 'Ã©',\n  ecirc: 'Ãª',\n  euml: 'Ã«',\n  igrave: 'Ã¬',\n  iacute: 'Ã­',\n  icirc: 'Ã®',\n  iuml: 'Ã¯',\n  eth: 'Ã°',\n  ntilde: 'Ã±',\n  ograve: 'Ã²',\n  oacute: 'Ã³',\n  ocirc: 'Ã´',\n  otilde: 'Ãµ',\n  ouml: 'Ã¶',\n  divide: 'Ã·',\n  oslash: 'Ã¸',\n  ugrave: 'Ã¹',\n  uacute: 'Ãº',\n  ucirc: 'Ã»',\n  uuml: 'Ã¼',\n  yacute: 'Ã½',\n  thorn: 'Ã¾',\n  yuml: 'Ã¿',\n  fnof: 'Æ’',\n  Alpha: 'Î‘',\n  Beta: 'Î’',\n  Gamma: 'Î“',\n  Delta: 'Î”',\n  Epsilon: 'Î•',\n  Zeta: 'Î–',\n  Eta: 'Î—',\n  Theta: 'Î˜',\n  Iota: 'Î™',\n  Kappa: 'Îš',\n  Lambda: 'Î›',\n  Mu: 'Îœ',\n  Nu: 'Î',\n  Xi: 'Îž',\n  Omicron: 'ÎŸ',\n  Pi: 'Î ',\n  Rho: 'Î¡',\n  Sigma: 'Î£',\n  Tau: 'Î¤',\n  Upsilon: 'Î¥',\n  Phi: 'Î¦',\n  Chi: 'Î§',\n  Psi: 'Î¨',\n  Omega: 'Î©',\n  alpha: 'Î±',\n  beta: 'Î²',\n  gamma: 'Î³',\n  delta: 'Î´',\n  epsilon: 'Îµ',\n  zeta: 'Î¶',\n  eta: 'Î·',\n  theta: 'Î¸',\n  iota: 'Î¹',\n  kappa: 'Îº',\n  lambda: 'Î»',\n  mu: 'Î¼',\n  nu: 'Î½',\n  xi: 'Î¾',\n  omicron: 'Î¿',\n  pi: 'Ï€',\n  rho: 'Ï',\n  sigmaf: 'Ï‚',\n  sigma: 'Ïƒ',\n  tau: 'Ï„',\n  upsilon: 'Ï…',\n  phi: 'Ï†',\n  chi: 'Ï‡',\n  psi: 'Ïˆ',\n  omega: 'Ï‰',\n  thetasym: 'Ï‘',\n  upsih: 'Ï’',\n  piv: 'Ï–',\n  bull: 'â€¢',\n  hellip: 'â€¦',\n  prime: 'â€²',\n  Prime: 'â€³',\n  oline: 'â€¾',\n  frasl: 'â„',\n  weierp: 'â„˜',\n  image: 'â„‘',\n  real: 'â„œ',\n  trade: 'â„¢',\n  alefsym: 'â„µ',\n  larr: 'â†',\n  uarr: 'â†‘',\n  rarr: 'â†’',\n  darr: 'â†“',\n  harr: 'â†”',\n  crarr: 'â†µ',\n  lArr: 'â‡',\n  uArr: 'â‡‘',\n  rArr: 'â‡’',\n  dArr: 'â‡“',\n  hArr: 'â‡”',\n  forall: 'âˆ€',\n  part: 'âˆ‚',\n  exist: 'âˆƒ',\n  empty: 'âˆ…',\n  nabla: 'âˆ‡',\n  isin: 'âˆˆ',\n  notin: 'âˆ‰',\n  ni: 'âˆ‹',\n  prod: 'âˆ',\n  sum: 'âˆ‘',\n  minus: 'âˆ’',\n  lowast: 'âˆ—',\n  radic: 'âˆš',\n  prop: 'âˆ',\n  infin: 'âˆž',\n  ang: 'âˆ ',\n  and: 'âˆ§',\n  or: 'âˆ¨',\n  cap: 'âˆ©',\n  cup: 'âˆª',\n  int: 'âˆ«',\n  there4: 'âˆ´',\n  sim: 'âˆ¼',\n  cong: 'â‰…',\n  asymp: 'â‰ˆ',\n  ne: 'â‰ ',\n  equiv: 'â‰¡',\n  le: 'â‰¤',\n  ge: 'â‰¥',\n  sub: 'âŠ‚',\n  sup: 'âŠƒ',\n  nsub: 'âŠ„',\n  sube: 'âŠ†',\n  supe: 'âŠ‡',\n  oplus: 'âŠ•',\n  otimes: 'âŠ—',\n  perp: 'âŠ¥',\n  sdot: 'â‹…',\n  lceil: 'âŒˆ',\n  rceil: 'âŒ‰',\n  lfloor: 'âŒŠ',\n  rfloor: 'âŒ‹',\n  lang: 'âŒ©',\n  rang: 'âŒª',\n  loz: 'â—Š',\n  spades: 'â™ ',\n  clubs: 'â™£',\n  hearts: 'â™¥',\n  diams: 'â™¦',\n  quot: '\"',\n  amp: '&',\n  lt: '<',\n  gt: '>',\n  OElig: 'Å’',\n  oelig: 'Å“',\n  Scaron: 'Å ',\n  scaron: 'Å¡',\n  Yuml: 'Å¸',\n  circ: 'Ë†',\n  tilde: 'Ëœ',\n  ensp: 'â€‚',\n  emsp: 'â€ƒ',\n  thinsp: 'â€‰',\n  zwnj: 'â€Œ',\n  zwj: 'â€',\n  lrm: 'â€Ž',\n  rlm: 'â€',\n  ndash: 'â€“',\n  mdash: 'â€”',\n  lsquo: 'â€˜',\n  rsquo: 'â€™',\n  sbquo: 'â€š',\n  ldquo: 'â€œ',\n  rdquo: 'â€',\n  bdquo: 'â€ž',\n  dagger: 'â€ ',\n  Dagger: 'â€¡',\n  permil: 'â€°',\n  lsaquo: 'â€¹',\n  rsaquo: 'â€º',\n  euro: 'â‚¬'\n}\n", "import {characterEntitiesLegacy} from 'character-entities-legacy'\nimport {characterEntitiesHtml4} from 'character-entities-html4'\nimport {dangerous} from '../constant/dangerous.js'\n\nconst own = {}.hasOwnProperty\n\n/**\n * `characterEntitiesHtml4` but inverted.\n *\n * @type {Record<string, string>}\n */\nconst characters = {}\n\n/** @type {string} */\nlet key\n\nfor (key in characterEntitiesHtml4) {\n  if (own.call(characterEntitiesHtml4, key)) {\n    characters[characterEntitiesHtml4[key]] = key\n  }\n}\n\nconst notAlphanumericRegex = /[^\\dA-Za-z]/\n\n/**\n * Configurable ways to encode characters as named references.\n *\n * @param {number} code\n * @param {number} next\n * @param {boolean|undefined} omit\n * @param {boolean|undefined} attribute\n * @returns {string}\n */\nexport function toNamed(code, next, omit, attribute) {\n  const character = String.fromCharCode(code)\n\n  if (own.call(characters, character)) {\n    const name = characters[character]\n    const value = '&' + name\n\n    if (\n      omit &&\n      characterEntitiesLegacy.includes(name) &&\n      !dangerous.includes(name) &&\n      (!attribute ||\n        (next &&\n          next !== 61 /* `=` */ &&\n          notAlphanumericRegex.test(String.fromCharCode(next))))\n    ) {\n      return value\n    }\n\n    return value + ';'\n  }\n\n  return ''\n}\n", "/**\n * The smallest way to encode a character.\n *\n * @param {number} code\n * @returns {string}\n */\nexport function formatBasic(code) {\n  return '&#x' + code.toString(16).toUpperCase() + ';'\n}\n", "/**\n * @typedef {import('./core.js').CoreOptions & import('./util/format-smart.js').FormatSmartOptions} Options\n * @typedef {import('./core.js').CoreOptions} LightOptions\n */\n\nimport {core} from './core.js'\nimport {formatSmart} from './util/format-smart.js'\nimport {formatBasic} from './util/format-basic.js'\n\n/**\n * Encode special characters in `value`.\n *\n * @param {string} value\n *   Value to encode.\n * @param {Options} [options]\n *   Configuration.\n * @returns {string}\n *   Encoded value.\n */\nexport function stringifyEntities(value, options) {\n  return core(value, Object.assign({format: formatSmart}, options))\n}\n\n/**\n * Encode special characters in `value` as hexadecimals.\n *\n * @param {string} value\n *   Value to encode.\n * @param {LightOptions} [options]\n *   Configuration.\n * @returns {string}\n *   Encoded value.\n */\nexport function stringifyEntitiesLight(value, options) {\n  return core(value, Object.assign({format: formatBasic}, options))\n}\n", "/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n */\n\n/**\n * @typedef {Record<string, unknown>} Props\n * @typedef {null | undefined | string | Props | TestFunctionAnything | Array<string | Props | TestFunctionAnything>} Test\n *   Check for an arbitrary node, unaware of TypeScript inferral.\n *\n * @callback TestFunctionAnything\n *   Check if a node passes a test, unaware of TypeScript inferral.\n * @param {unknown} this\n *   The given context.\n * @param {Node} node\n *   A node.\n * @param {number | null | undefined} [index]\n *   The nodeâ€™s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The nodeâ€™s parent.\n * @returns {boolean | void}\n *   Whether this node passes the test.\n */\n\n/**\n * @template {Node} Kind\n *   Node type.\n * @typedef {Kind['type'] | Partial<Kind> | TestFunctionPredicate<Kind> | Array<Kind['type'] | Partial<Kind> | TestFunctionPredicate<Kind>>} PredicateTest\n *   Check for a node that can be inferred by TypeScript.\n */\n\n/**\n * Check if a node passes a certain test.\n *\n * @template {Node} Kind\n *   Node type.\n * @callback TestFunctionPredicate\n *   Complex test function for a node that can be inferred by TypeScript.\n * @param {Node} node\n *   A node.\n * @param {number | null | undefined} [index]\n *   The nodeâ€™s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The nodeâ€™s parent.\n * @returns {node is Kind}\n *   Whether this node passes the test.\n */\n\n/**\n * @callback AssertAnything\n *   Check that an arbitrary value is a node, unaware of TypeScript inferral.\n * @param {unknown} [node]\n *   Anything (typically a node).\n * @param {number | null | undefined} [index]\n *   The nodeâ€™s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The nodeâ€™s parent.\n * @returns {boolean}\n *   Whether this is a node and passes a test.\n */\n\n/**\n * Check if a node is a node and passes a certain node test.\n *\n * @template {Node} Kind\n *   Node type.\n * @callback AssertPredicate\n *   Check that an arbitrary value is a specific node, aware of TypeScript.\n * @param {unknown} [node]\n *   Anything (typically a node).\n * @param {number | null | undefined} [index]\n *   The nodeâ€™s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The nodeâ€™s parent.\n * @returns {node is Kind}\n *   Whether this is a node and passes a test.\n */\n\n/**\n * Check if `node` is a `Node` and whether it passes the given test.\n *\n * @param node\n *   Thing to check, typically `Node`.\n * @param test\n *   A check for a specific node.\n * @param index\n *   The nodeâ€™s position in its parent.\n * @param parent\n *   The nodeâ€™s parent.\n * @returns\n *   Whether `node` is a node and passes a test.\n */\nexport const is =\n  /**\n   * @type {(\n   *   (() => false) &\n   *   (<Kind extends Node = Node>(node: unknown, test: PredicateTest<Kind>, index: number, parent: Parent, context?: unknown) => node is Kind) &\n   *   (<Kind extends Node = Node>(node: unknown, test: PredicateTest<Kind>, index?: null | undefined, parent?: null | undefined, context?: unknown) => node is Kind) &\n   *   ((node: unknown, test: Test, index: number, parent: Parent, context?: unknown) => boolean) &\n   *   ((node: unknown, test?: Test, index?: null | undefined, parent?: null | undefined, context?: unknown) => boolean)\n   * )}\n   */\n  (\n    /**\n     * @param {unknown} [node]\n     * @param {Test} [test]\n     * @param {number | null | undefined} [index]\n     * @param {Parent | null | undefined} [parent]\n     * @param {unknown} [context]\n     * @returns {boolean}\n     */\n    // eslint-disable-next-line max-params\n    function is(node, test, index, parent, context) {\n      const check = convert(test)\n\n      if (\n        index !== undefined &&\n        index !== null &&\n        (typeof index !== 'number' ||\n          index < 0 ||\n          index === Number.POSITIVE_INFINITY)\n      ) {\n        throw new Error('Expected positive finite index')\n      }\n\n      if (\n        parent !== undefined &&\n        parent !== null &&\n        (!is(parent) || !parent.children)\n      ) {\n        throw new Error('Expected parent node')\n      }\n\n      if (\n        (parent === undefined || parent === null) !==\n        (index === undefined || index === null)\n      ) {\n        throw new Error('Expected both parent and index')\n      }\n\n      // @ts-expect-error Looks like a node.\n      return node && node.type && typeof node.type === 'string'\n        ? Boolean(check.call(context, node, index, parent))\n        : false\n    }\n  )\n\n/**\n * Generate an assertion from a test.\n *\n * Useful if youâ€™re going to test many nodes, for example when creating a\n * utility where something else passes a compatible test.\n *\n * The created function is a bit faster because it expects valid input only:\n * a `node`, `index`, and `parent`.\n *\n * @param test\n *   *   when nullish, checks if `node` is a `Node`.\n *   *   when `string`, works like passing `(node) => node.type === test`.\n *   *   when `function` checks if function passed the node is true.\n *   *   when `object`, checks that all keys in test are in node, and that they have (strictly) equal values.\n *   *   when `array`, checks if any one of the subtests pass.\n * @returns\n *   An assertion.\n */\nexport const convert =\n  /**\n   * @type {(\n   *   (<Kind extends Node>(test: PredicateTest<Kind>) => AssertPredicate<Kind>) &\n   *   ((test?: Test) => AssertAnything)\n   * )}\n   */\n  (\n    /**\n     * @param {Test} [test]\n     * @returns {AssertAnything}\n     */\n    function (test) {\n      if (test === undefined || test === null) {\n        return ok\n      }\n\n      if (typeof test === 'string') {\n        return typeFactory(test)\n      }\n\n      if (typeof test === 'object') {\n        return Array.isArray(test) ? anyFactory(test) : propsFactory(test)\n      }\n\n      if (typeof test === 'function') {\n        return castFactory(test)\n      }\n\n      throw new Error('Expected function, string, or object as test')\n    }\n  )\n\n/**\n * @param {Array<string | Props | TestFunctionAnything>} tests\n * @returns {AssertAnything}\n */\nfunction anyFactory(tests) {\n  /** @type {Array<AssertAnything>} */\n  const checks = []\n  let index = -1\n\n  while (++index < tests.length) {\n    checks[index] = convert(tests[index])\n  }\n\n  return castFactory(any)\n\n  /**\n   * @this {unknown}\n   * @param {Array<unknown>} parameters\n   * @returns {boolean}\n   */\n  function any(...parameters) {\n    let index = -1\n\n    while (++index < checks.length) {\n      if (checks[index].call(this, ...parameters)) return true\n    }\n\n    return false\n  }\n}\n\n/**\n * Turn an object into a test for a node with a certain fields.\n *\n * @param {Props} check\n * @returns {AssertAnything}\n */\nfunction propsFactory(check) {\n  return castFactory(all)\n\n  /**\n   * @param {Node} node\n   * @returns {boolean}\n   */\n  function all(node) {\n    /** @type {string} */\n    let key\n\n    for (key in check) {\n      // @ts-expect-error: hush, it sure works as an index.\n      if (node[key] !== check[key]) return false\n    }\n\n    return true\n  }\n}\n\n/**\n * Turn a string into a test for a node with a certain type.\n *\n * @param {string} check\n * @returns {AssertAnything}\n */\nfunction typeFactory(check) {\n  return castFactory(type)\n\n  /**\n   * @param {Node} node\n   */\n  function type(node) {\n    return node && node.type === check\n  }\n}\n\n/**\n * Turn a custom test into a test for a node that passes that test.\n *\n * @param {TestFunctionAnything} check\n * @returns {AssertAnything}\n */\nfunction castFactory(check) {\n  return assertion\n\n  /**\n   * @this {unknown}\n   * @param {unknown} node\n   * @param {Array<unknown>} parameters\n   * @returns {boolean}\n   */\n  function assertion(node, ...parameters) {\n    return Boolean(\n      node &&\n        typeof node === 'object' &&\n        'type' in node &&\n        // @ts-expect-error: fine.\n        Boolean(check.call(this, node, ...parameters))\n    )\n  }\n}\n\nfunction ok() {\n  return true\n}\n", "/**\n * @param {string} d\n * @returns {string}\n */\nexport function color(d) {\n  return d\n}\n", "/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n * @typedef {import('unist-util-is').Test} Test\n */\n\n/**\n * @typedef {boolean | 'skip'} Action\n *   Union of the action types.\n *\n * @typedef {number} Index\n *   Move to the sibling at `index` next (after node itself is completely\n *   traversed).\n *\n *   Useful if mutating the tree, such as removing the node the visitor is\n *   currently on, or any of its previous siblings.\n *   Results less than 0 or greater than or equal to `children.length` stop\n *   traversing the parent.\n *\n * @typedef {[(Action | null | undefined | void)?, (Index | null | undefined)?]} ActionTuple\n *   List with one or two values, the first an action, the second an index.\n *\n * @typedef {Action | ActionTuple | Index | null | undefined | void} VisitorResult\n *   Any value that can be returned from a visitor.\n */\n\n/**\n * @template {Node} [Visited=Node]\n *   Visited node type.\n * @template {Parent} [Ancestor=Parent]\n *   Ancestor type.\n * @callback Visitor\n *   Handle a node (matching `test`, if given).\n *\n *   Visitors are free to transform `node`.\n *   They can also transform the parent of node (the last of `ancestors`).\n *\n *   Replacing `node` itself, if `SKIP` is not returned, still causes its\n *   descendants to be walked (which is a bug).\n *\n *   When adding or removing previous siblings of `node` (or next siblings, in\n *   case of reverse), the `Visitor` should return a new `Index` to specify the\n *   sibling to traverse after `node` is traversed.\n *   Adding or removing next siblings of `node` (or previous siblings, in case\n *   of reverse) is handled as expected without needing to return a new `Index`.\n *\n *   Removing the children property of an ancestor still results in them being\n *   traversed.\n * @param {Visited} node\n *   Found node.\n * @param {Array<Ancestor>} ancestors\n *   Ancestors of `node`.\n * @returns {VisitorResult}\n *   What to do next.\n *\n *   An `Index` is treated as a tuple of `[CONTINUE, Index]`.\n *   An `Action` is treated as a tuple of `[Action]`.\n *\n *   Passing a tuple back only makes sense if the `Action` is `SKIP`.\n *   When the `Action` is `EXIT`, that action can be returned.\n *   When the `Action` is `CONTINUE`, `Index` can be returned.\n */\n\n/**\n * @template {Node} [Tree=Node]\n *   Tree type.\n * @template {Test} [Check=string]\n *   Test type.\n * @typedef {Visitor<import('./complex-types.js').Matches<import('./complex-types.js').InclusiveDescendant<Tree>, Check>, Extract<import('./complex-types.js').InclusiveDescendant<Tree>, Parent>>} BuildVisitor\n *   Build a typed `Visitor` function from a tree and a test.\n *\n *   It will infer which values are passed as `node` and which as `parents`.\n */\n\nimport {convert} from 'unist-util-is'\nimport {color} from './color.js'\n\n/**\n * Continue traversing as normal.\n */\nexport const CONTINUE = true\n\n/**\n * Stop traversing immediately.\n */\nexport const EXIT = false\n\n/**\n * Do not traverse this nodeâ€™s children.\n */\nexport const SKIP = 'skip'\n\n/**\n * Visit nodes, with ancestral information.\n *\n * This algorithm performs *depth-first* *tree traversal* in *preorder*\n * (**NLR**) or if `reverse` is given, in *reverse preorder* (**NRL**).\n *\n * You can choose for which nodes `visitor` is called by passing a `test`.\n * For complex tests, you should test yourself in `visitor`, as it will be\n * faster and will have improved type information.\n *\n * Walking the tree is an intensive task.\n * Make use of the return values of the visitor when possible.\n * Instead of walking a tree multiple times, walk it once, use `unist-util-is`\n * to check if a node matches, and then perform different operations.\n *\n * You can change the tree.\n * See `Visitor` for more info.\n *\n * @param tree\n *   Tree to traverse.\n * @param test\n *   `unist-util-is`-compatible test\n * @param visitor\n *   Handle each node.\n * @param reverse\n *   Traverse in reverse preorder (NRL) instead of the default preorder (NLR).\n * @returns\n *   Nothing.\n */\nexport const visitParents =\n  /**\n   * @type {(\n   *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: BuildVisitor<Tree, Check>, reverse?: boolean | null | undefined) => void) &\n   *   (<Tree extends Node>(tree: Tree, visitor: BuildVisitor<Tree>, reverse?: boolean | null | undefined) => void)\n   * )}\n   */\n  (\n    /**\n     * @param {Node} tree\n     * @param {Test} test\n     * @param {Visitor<Node>} visitor\n     * @param {boolean | null | undefined} [reverse]\n     * @returns {void}\n     */\n    function (tree, test, visitor, reverse) {\n      if (typeof test === 'function' && typeof visitor !== 'function') {\n        reverse = visitor\n        // @ts-expect-error no visitor given, so `visitor` is test.\n        visitor = test\n        test = null\n      }\n\n      const is = convert(test)\n      const step = reverse ? -1 : 1\n\n      factory(tree, undefined, [])()\n\n      /**\n       * @param {Node} node\n       * @param {number | undefined} index\n       * @param {Array<Parent>} parents\n       */\n      function factory(node, index, parents) {\n        /** @type {Record<string, unknown>} */\n        // @ts-expect-error: hush\n        const value = node && typeof node === 'object' ? node : {}\n\n        if (typeof value.type === 'string') {\n          const name =\n            // `hast`\n            typeof value.tagName === 'string'\n              ? value.tagName\n              : // `xast`\n              typeof value.name === 'string'\n              ? value.name\n              : undefined\n\n          Object.defineProperty(visit, 'name', {\n            value:\n              'node (' + color(node.type + (name ? '<' + name + '>' : '')) + ')'\n          })\n        }\n\n        return visit\n\n        function visit() {\n          /** @type {ActionTuple} */\n          let result = []\n          /** @type {ActionTuple} */\n          let subresult\n          /** @type {number} */\n          let offset\n          /** @type {Array<Parent>} */\n          let grandparents\n\n          if (!test || is(node, index, parents[parents.length - 1] || null)) {\n            result = toResult(visitor(node, parents))\n\n            if (result[0] === EXIT) {\n              return result\n            }\n          }\n\n          // @ts-expect-error looks like a parent.\n          if (node.children && result[0] !== SKIP) {\n            // @ts-expect-error looks like a parent.\n            offset = (reverse ? node.children.length : -1) + step\n            // @ts-expect-error looks like a parent.\n            grandparents = parents.concat(node)\n\n            // @ts-expect-error looks like a parent.\n            while (offset > -1 && offset < node.children.length) {\n              // @ts-expect-error looks like a parent.\n              subresult = factory(node.children[offset], offset, grandparents)()\n\n              if (subresult[0] === EXIT) {\n                return subresult\n              }\n\n              offset =\n                typeof subresult[1] === 'number' ? subresult[1] : offset + step\n            }\n          }\n\n          return result\n        }\n      }\n    }\n  )\n\n/**\n * Turn a return value into a clean result.\n *\n * @param {VisitorResult} value\n *   Valid return values from visitors.\n * @returns {ActionTuple}\n *   Clean result.\n */\nfunction toResult(value) {\n  if (Array.isArray(value)) {\n    return value\n  }\n\n  if (typeof value === 'number') {\n    return [CONTINUE, value]\n  }\n\n  return [value]\n}\n", "/**\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Options} Options\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['quote'], null | undefined>}\n */\nexport function checkQuote(state) {\n  const marker = state.options.quote || '\"'\n\n  if (marker !== '\"' && marker !== \"'\") {\n    throw new Error(\n      'Cannot serialize title with `' +\n        marker +\n        '` for `options.quote`, expected `\"`, or `\\'`'\n    )\n  }\n\n  return marker\n}\n", "/**\n * @typedef {import('mdast').BlockContent} BlockContent\n * @typedef {import('mdast').DefinitionContent} DefinitionContent\n * @typedef {import('mdast').Paragraph} Paragraph\n *\n * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\n * @typedef {import('mdast-util-from-markdown').Token} Token\n *\n * @typedef {import('mdast-util-to-markdown').ConstructName} ConstructName\n * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n * @typedef {import('mdast-util-to-markdown').State} State\n *\n * @typedef {import('../index.js').LeafDirective} LeafDirective\n * @typedef {import('../index.js').TextDirective} TextDirective\n * @typedef {import('../index.js').Directive} Directive\n */\n\nimport {parseEntities} from 'parse-entities'\nimport {stringifyEntitiesLight} from 'stringify-entities'\nimport {visitParents} from 'unist-util-visit-parents'\nimport {containerFlow} from 'mdast-util-to-markdown/lib/util/container-flow.js'\nimport {containerPhrasing} from 'mdast-util-to-markdown/lib/util/container-phrasing.js'\nimport {checkQuote} from 'mdast-util-to-markdown/lib/util/check-quote.js'\nimport {track} from 'mdast-util-to-markdown/lib/util/track.js'\n\n// To do: next major: replace `containerFlow`, `containerPhrasing`, `track`\n// with `state` methods.\n// To do: next major: expose functions.\n\nconst own = {}.hasOwnProperty\n\nconst shortcut = /^[^\\t\\n\\r \"#'.<=>`}]+$/\n\nhandleDirective.peek = peekDirective\n\n/**\n * Extension for `mdast-util-from-markdown` to enable directives.\n *\n * @type {FromMarkdownExtension}\n */\nexport const directiveFromMarkdown = {\n  canContainEols: ['textDirective'],\n  enter: {\n    directiveContainer: enterContainer,\n    directiveContainerAttributes: enterAttributes,\n    directiveContainerLabel: enterContainerLabel,\n\n    directiveLeaf: enterLeaf,\n    directiveLeafAttributes: enterAttributes,\n\n    directiveText: enterText,\n    directiveTextAttributes: enterAttributes\n  },\n  exit: {\n    directiveContainer: exit,\n    directiveContainerAttributeClassValue: exitAttributeClassValue,\n    directiveContainerAttributeIdValue: exitAttributeIdValue,\n    directiveContainerAttributeName: exitAttributeName,\n    directiveContainerAttributeValue: exitAttributeValue,\n    directiveContainerAttributes: exitAttributes,\n    directiveContainerLabel: exitContainerLabel,\n    directiveContainerName: exitName,\n\n    directiveLeaf: exit,\n    directiveLeafAttributeClassValue: exitAttributeClassValue,\n    directiveLeafAttributeIdValue: exitAttributeIdValue,\n    directiveLeafAttributeName: exitAttributeName,\n    directiveLeafAttributeValue: exitAttributeValue,\n    directiveLeafAttributes: exitAttributes,\n    directiveLeafName: exitName,\n\n    directiveText: exit,\n    directiveTextAttributeClassValue: exitAttributeClassValue,\n    directiveTextAttributeIdValue: exitAttributeIdValue,\n    directiveTextAttributeName: exitAttributeName,\n    directiveTextAttributeValue: exitAttributeValue,\n    directiveTextAttributes: exitAttributes,\n    directiveTextName: exitName\n  }\n}\n\n/**\n * Extension for `mdast-util-to-markdown` to enable directives.\n *\n * @type {ToMarkdownExtension}\n */\nexport const directiveToMarkdown = {\n  unsafe: [\n    {\n      character: '\\r',\n      inConstruct: ['leafDirectiveLabel', 'containerDirectiveLabel']\n    },\n    {\n      character: '\\n',\n      inConstruct: ['leafDirectiveLabel', 'containerDirectiveLabel']\n    },\n    {\n      before: '[^:]',\n      character: ':',\n      after: '[A-Za-z]',\n      inConstruct: ['phrasing']\n    },\n    {atBreak: true, character: ':', after: ':'}\n  ],\n  handlers: {\n    containerDirective: handleDirective,\n    leafDirective: handleDirective,\n    textDirective: handleDirective\n  }\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterContainer(token) {\n  enter.call(this, 'containerDirective', token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterLeaf(token) {\n  enter.call(this, 'leafDirective', token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterText(token) {\n  enter.call(this, 'textDirective', token)\n}\n\n/**\n * @this {CompileContext}\n * @param {Directive['type']} type\n * @param {Token} token\n */\nfunction enter(type, token) {\n  this.enter({type, name: '', attributes: {}, children: []}, token)\n}\n\n/**\n * @this {CompileContext}\n * @param {Token} token\n */\nfunction exitName(token) {\n  const node = /** @type {Directive} */ (this.stack[this.stack.length - 1])\n  node.name = this.sliceSerialize(token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterContainerLabel(token) {\n  this.enter(\n    {type: 'paragraph', data: {directiveLabel: true}, children: []},\n    token\n  )\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitContainerLabel(token) {\n  this.exit(token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterAttributes() {\n  this.setData('directiveAttributes', [])\n  this.buffer() // Capture EOLs\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitAttributeIdValue(token) {\n  const list = /** @type {Array<[string, string]>} */ (\n    this.getData('directiveAttributes')\n  )\n  list.push([\n    'id',\n    parseEntities(this.sliceSerialize(token), {\n      attribute: true\n    })\n  ])\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitAttributeClassValue(token) {\n  const list = /** @type {Array<[string, string]>} */ (\n    this.getData('directiveAttributes')\n  )\n  list.push([\n    'class',\n    parseEntities(this.sliceSerialize(token), {\n      attribute: true\n    })\n  ])\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitAttributeValue(token) {\n  const list = /** @type {Array<[string, string]>} */ (\n    this.getData('directiveAttributes')\n  )\n  list[list.length - 1][1] = parseEntities(this.sliceSerialize(token), {\n    attribute: true\n  })\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitAttributeName(token) {\n  const list = /** @type {Array<[string, string]>} */ (\n    this.getData('directiveAttributes')\n  )\n\n  // Attribute names in CommonMark are significantly limited, so character\n  // references canâ€™t exist.\n  list.push([this.sliceSerialize(token), ''])\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitAttributes() {\n  const list = /** @type {Array<[string, string]>} */ (\n    this.getData('directiveAttributes')\n  )\n  /** @type {Record<string, string>} */\n  const cleaned = {}\n  let index = -1\n\n  while (++index < list.length) {\n    const attribute = list[index]\n\n    if (attribute[0] === 'class' && cleaned.class) {\n      cleaned.class += ' ' + attribute[1]\n    } else {\n      cleaned[attribute[0]] = attribute[1]\n    }\n  }\n\n  this.setData('directiveAttributes')\n  this.resume() // Drop EOLs\n  const node = /** @type {Directive} */ (this.stack[this.stack.length - 1])\n  node.attributes = cleaned\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exit(token) {\n  this.exit(token)\n}\n\n/**\n * @type {ToMarkdownHandle}\n * @param {Directive} node\n */\nfunction handleDirective(node, _, state, safeOptions) {\n  const tracker = track(safeOptions)\n  const sequence = fence(node)\n  const exit = state.enter(node.type)\n  let value = tracker.move(sequence + (node.name || ''))\n  /** @type {Paragraph | LeafDirective | TextDirective | undefined} */\n  let label\n\n  if (node.type === 'containerDirective') {\n    const head = (node.children || [])[0]\n    label = inlineDirectiveLabel(head) ? head : undefined\n  } else {\n    label = node\n  }\n\n  if (label && label.children && label.children.length > 0) {\n    const exit = state.enter('label')\n    /** @type {ConstructName} */\n    const labelType = `${node.type}Label`\n    const subexit = state.enter(labelType)\n    value += tracker.move('[')\n    value += tracker.move(\n      containerPhrasing(label, state, {\n        ...tracker.current(),\n        before: value,\n        after: ']'\n      })\n    )\n    value += tracker.move(']')\n    subexit()\n    exit()\n  }\n\n  value += tracker.move(attributes(node, state))\n\n  if (node.type === 'containerDirective') {\n    const head = (node.children || [])[0]\n    let shallow = node\n\n    if (inlineDirectiveLabel(head)) {\n      shallow = Object.assign({}, node, {children: node.children.slice(1)})\n    }\n\n    if (shallow && shallow.children && shallow.children.length > 0) {\n      value += tracker.move('\\n')\n      value += tracker.move(containerFlow(shallow, state, tracker.current()))\n    }\n\n    value += tracker.move('\\n' + sequence)\n  }\n\n  exit()\n  return value\n}\n\n/** @type {ToMarkdownHandle} */\nfunction peekDirective() {\n  return ':'\n}\n\n/**\n * @param {Directive} node\n * @param {State} state\n * @returns {string}\n */\nfunction attributes(node, state) {\n  const quote = checkQuote(state)\n  const subset = node.type === 'textDirective' ? [quote] : [quote, '\\n', '\\r']\n  const attrs = node.attributes || {}\n  /** @type {Array<string>} */\n  const values = []\n  /** @type {string | undefined} */\n  let classesFull\n  /** @type {string | undefined} */\n  let classes\n  /** @type {string | undefined} */\n  let id\n  /** @type {string} */\n  let key\n\n  for (key in attrs) {\n    if (\n      own.call(attrs, key) &&\n      attrs[key] !== undefined &&\n      attrs[key] !== null\n    ) {\n      const value = String(attrs[key])\n\n      if (key === 'id') {\n        id = shortcut.test(value) ? '#' + value : quoted('id', value)\n      } else if (key === 'class') {\n        const list = value.split(/[\\t\\n\\r ]+/g)\n        /** @type {Array<string>} */\n        const classesFullList = []\n        /** @type {Array<string>} */\n        const classesList = []\n        let index = -1\n\n        while (++index < list.length) {\n          ;(shortcut.test(list[index]) ? classesList : classesFullList).push(\n            list[index]\n          )\n        }\n\n        classesFull =\n          classesFullList.length > 0\n            ? quoted('class', classesFullList.join(' '))\n            : ''\n        classes = classesList.length > 0 ? '.' + classesList.join('.') : ''\n      } else {\n        values.push(quoted(key, value))\n      }\n    }\n  }\n\n  if (classesFull) {\n    values.unshift(classesFull)\n  }\n\n  if (classes) {\n    values.unshift(classes)\n  }\n\n  if (id) {\n    values.unshift(id)\n  }\n\n  return values.length > 0 ? '{' + values.join(' ') + '}' : ''\n\n  /**\n   * @param {string} key\n   * @param {string} value\n   * @returns {string}\n   */\n  function quoted(key, value) {\n    return (\n      key +\n      (value\n        ? '=' + quote + stringifyEntitiesLight(value, {subset}) + quote\n        : '')\n    )\n  }\n}\n\n/**\n * @param {BlockContent | DefinitionContent} node\n * @returns {node is Paragraph & {data: {directiveLabel: boolean}}}\n */\nfunction inlineDirectiveLabel(node) {\n  return Boolean(\n    node && node.type === 'paragraph' && node.data && node.data.directiveLabel\n  )\n}\n\n/**\n * @param {Directive} node\n * @returns {string}\n */\nfunction fence(node) {\n  let size = 0\n\n  if (node.type === 'containerDirective') {\n    visitParents(node, function (node, parents) {\n      if (node.type === 'containerDirective') {\n        let index = parents.length\n        let nesting = 0\n\n        while (index--) {\n          if (parents[index].type === 'containerDirective') {\n            nesting++\n          }\n        }\n\n        if (nesting > size) size = nesting\n      }\n    })\n    size += 3\n  } else if (node.type === 'leafDirective') {\n    size = 2\n  } else {\n    size = 1\n  }\n\n  return ':'.repeat(size)\n}\n", "/**\n * @typedef {import('mdast').Root} Root\n *\n * @typedef {import('mdast-util-directive')} DoNotTouchAsThisImportIncludesDirectivesInTree\n */\n\nimport {directive} from 'micromark-extension-directive'\nimport {directiveFromMarkdown, directiveToMarkdown} from 'mdast-util-directive'\n\n/**\n * Plugin to support the generic directives proposal (`:cite[smith04]`,\n * `::youtube[Video of a cat in a box]{v=01ab2cd3efg}`, and such).\n *\n * @type {import('unified').Plugin<void[], Root>}\n */\nexport default function remarkDirective() {\n  const data = this.data()\n\n  add('micromarkExtensions', directive())\n  add('fromMarkdownExtensions', directiveFromMarkdown)\n  add('toMarkdownExtensions', directiveToMarkdown)\n\n  /**\n   * @param {string} field\n   * @param {unknown} value\n   */\n  function add(field, value) {\n    const list = /** @type {unknown[]} */ (\n      // Other extensions\n      /* c8 ignore next 2 */\n      data[field] ? data[field] : (data[field] = [])\n    )\n\n    list.push(value)\n  }\n}\n"],
  "mappings": "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QAAQ;AAAA,EACR,KAAK;AAAA,EACL,QAAQ;AAAA,EACR,MAAM;AAAA,EACN,KAAK;AAAA,EACL,MAAM;AAAA,EACN,MAAM;AAAA,EACN,OAAO;AAAA,EACP,KAAK;AAAA,EACL,KAAK;AAAA,EACL,KAAK;AAAA,EACL,MAAM;AAAA,EACN,KAAK;AAAA,EACL,QAAQ;AAAA,EACR,MAAM;AAAA,EACN,MAAM;AAAA,EACN,OAAO;AAAA,EACP,OAAO;AAAA,EACP,MAAM;AAAA,EACN,QAAQ;AAAA,EACR,OAAO;AAAA,EACP,MAAM;AAAA,EACN,MAAM;AAAA,EACN,OAAO;AAAA,EACP,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,OAAO;AAAA,EACP,QAAQ;AAAA,EACR,MAAM;AAAA,EACN,OAAO;AAAA,EACP,OAAO;AAAA,EACP,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,OAAO;AAAA,EACP,MAAM;AAAA,EACN,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,OAAO;AAAA,EACP,MAAM;AAAA,EACN,KAAK;AAAA,EACL,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,OAAO;AAAA,EACP,QAAQ;AAAA,EACR,MAAM;AAAA,EACN,OAAO;AAAA,EACP,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,OAAO;AAAA,EACP,MAAM;AAAA,EACN,QAAQ;AAAA,EACR,OAAO;AAAA,EACP,OAAO;AAAA,EACP,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,OAAO;AAAA,EACP,QAAQ;AAAA,EACR,MAAM;AAAA,EACN,OAAO;AAAA,EACP,OAAO;AAAA,EACP,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,OAAO;AAAA,EACP,MAAM;AAAA,EACN,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,OAAO;AAAA,EACP,MAAM;AAAA,EACN,KAAK;AAAA,EACL,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,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",
  "names": ["ok", "shortcut", "ok", "previous", "ok", "ok", "previous", "effects", "nok", "label", "tokenizeLabel", "attributes", "tokenizeAttributes", "ok", "label", "tokenizeLabel", "attributes", "tokenizeAttributes", "ok", "previous", "following", "characters", "own", "ok", "index", "key", "is", "own", "exit", "label", "attributes", "key", "node"]
}

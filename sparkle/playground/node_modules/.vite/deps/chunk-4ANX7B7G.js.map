{
  "version": 3,
  "sources": ["../../../../node_modules/decode-named-character-reference/index.dom.js", "../../../../node_modules/micromark-factory-whitespace/dev/index.js"],
  "sourcesContent": ["/// <reference lib=\"dom\" />\n\n/* eslint-env browser */\n\nconst element = document.createElement('i')\n\n/**\n * @param {string} value\n * @returns {string|false}\n */\nexport function decodeNamedCharacterReference(value) {\n  const characterReference = '&' + value + ';'\n  element.innerHTML = characterReference\n  const char = element.textContent\n\n  // Some named character references do not require the closing semicolon\n  // (`&not`, for instance), which leads to situations where parsing the assumed\n  // named reference of `&notit;` will result in the string `Â¬it;`.\n  // When we encounter a trailing semicolon after parsing, and the character\n  // reference to decode was not a semicolon (`&semi;`), we can assume that the\n  // matching was not complete.\n  // @ts-expect-error: TypeScript is wrong that `textContent` on elements can\n  // yield `null`.\n  if (char.charCodeAt(char.length - 1) === 59 /* `;` */ && value !== 'semi') {\n    return false\n  }\n\n  // If the decoded string is equal to the input, the character reference was\n  // not valid.\n  // @ts-expect-error: TypeScript is wrong that `textContent` on elements can\n  // yield `null`.\n  return char === characterReference ? false : char\n}\n", "/**\n * @typedef {import('micromark-util-types').Effects} Effects\n * @typedef {import('micromark-util-types').State} State\n */\n\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownLineEnding, markdownSpace} from 'micromark-util-character'\nimport {types} from 'micromark-util-symbol/types.js'\n\n/**\n * Parse spaces and tabs.\n *\n * There is no `nok` parameter:\n *\n * *   line endings or spaces in markdown are often optional, in which case this\n *     factory can be used and `ok` will be switched to whether spaces were found\n *     or not\n * *   one line ending or space can be detected with\n *     `markdownLineEndingOrSpace(code)` right before using `factoryWhitespace`\n *\n * @param {Effects} effects\n *   Context.\n * @param {State} ok\n *   State switched to when successful.\n * @returns\n *   Start state.\n */\nexport function factoryWhitespace(effects, ok) {\n  /** @type {boolean} */\n  let seen\n\n  return start\n\n  /** @type {State} */\n  function start(code) {\n    if (markdownLineEnding(code)) {\n      effects.enter(types.lineEnding)\n      effects.consume(code)\n      effects.exit(types.lineEnding)\n      seen = true\n      return start\n    }\n\n    if (markdownSpace(code)) {\n      return factorySpace(\n        effects,\n        start,\n        seen ? types.linePrefix : types.lineSuffix\n      )(code)\n    }\n\n    return ok(code)\n  }\n}\n"],
  "mappings": ";;;;;;;;AAIA,IAAM,UAAU,SAAS,cAAc,GAAG;AAMnC,SAAS,8BAA8B,OAAO;AACnD,QAAM,qBAAqB,MAAM,QAAQ;AACzC,UAAQ,YAAY;AACpB,QAAM,OAAO,QAAQ;AAUrB,MAAI,KAAK,WAAW,KAAK,SAAS,CAAC,MAAM,MAAgB,UAAU,QAAQ;AACzE,WAAO;AAAA,EACT;AAMA,SAAO,SAAS,qBAAqB,QAAQ;AAC/C;;;ACLO,SAAS,kBAAkB,SAAS,IAAI;AAE7C,MAAI;AAEJ,SAAO;AAGP,WAAS,MAAM,MAAM;AACnB,QAAI,mBAAmB,IAAI,GAAG;AAC5B,cAAQ,MAAM,MAAM,UAAU;AAC9B,cAAQ,QAAQ,IAAI;AACpB,cAAQ,KAAK,MAAM,UAAU;AAC7B,aAAO;AACP,aAAO;AAAA,IACT;AAEA,QAAI,cAAc,IAAI,GAAG;AACvB,aAAO;AAAA,QACL;AAAA,QACA;AAAA,QACA,OAAO,MAAM,aAAa,MAAM;AAAA,MAClC,EAAE,IAAI;AAAA,IACR;AAEA,WAAO,GAAG,IAAI;AAAA,EAChB;AACF;",
  "names": []
}
